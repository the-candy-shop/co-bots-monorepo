{
  "language": "Solidity",
  "sources": {
    "contracts/co-bots/CoBots.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"erc721a/contracts/ERC721A.sol\";\nimport \"../interfaces/ICoBotsRenderer.sol\";\n\ncontract OwnableDelegateProxy {}\n\ncontract ProxyRegistry {\n    mapping(address => OwnableDelegateProxy) public proxies;\n}\n\ncontract CoBots is ERC721A, VRFConsumerBaseV2, Ownable, ReentrancyGuard {\n    // Constants\n    uint256 public constant MAX_COBOTS = 10_000;\n    uint256 public constant MINT_PUBLIC_PRICE = 0.05 ether;\n    uint8 public constant MAX_MINT_PER_ADDRESS = 20;\n    uint8 public constant MINT_GIVEAWAYS = 30;\n    uint8 public constant MINT_FOUNDERS_AND_GIVEAWAYS = 50;\n    uint256 public constant COBOTS_MINT_DURATION = 168 hours;\n    uint256 public constant COBOTS_MINT_RAFFLE_DELAY = 1 days;\n    uint256 public constant COBOTS_REFUND_DURATION = 168 hours;\n    uint256 public constant RAFFLE_DRAW_DELAY = 1 minutes;\n    uint256 public constant MAIN_RAFFLE_PRIZE = 25 ether;\n    uint8 public constant MAIN_RAFFLE_WINNERS_COUNT = 10;\n    uint256 public constant COORDINATION_RAFFLE_PRIZE = 2.5 ether;\n    uint8 public constant COORDINATION_RAFFLE_WINNERS_COUNT = 20;\n    uint16 public constant COORDINATION_RAFFLE_THRESHOLD = 9_500;\n\n    // CoBots states variables\n    uint8[10_000] public coBotsSeeds;\n    bool[10_000] public coBotsStatusDisabled;\n    bool[10_000] public coBotsColors;\n    bool[10_000] public coBotsRefunded;\n    uint16 public coBotsColorAgreement = 5000; // cobots are minted 50%/50%\n\n    ////////////////////////////////////////////////////////////////////////\n    ////////////////////////// Schedule ////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////\n    uint256 public publicSaleStartTimestamp;\n\n    function setPublicSaleTimestamp(uint256 timestamp) external onlyOwner {\n        publicSaleStartTimestamp = timestamp;\n    }\n\n    function isPublicSaleOpen() public view returns (bool) {\n        return\n            block.timestamp > publicSaleStartTimestamp &&\n            publicSaleStartTimestamp != 0 &&\n            block.timestamp < publicSaleStartTimestamp + COBOTS_MINT_DURATION;\n    }\n\n    modifier whenPublicSaleOpen() {\n        require(isPublicSaleOpen(), \"Public sale not open\");\n        _;\n    }\n\n    modifier whenPublicSaleClosed() {\n        require(!isPublicSaleOpen(), \"Public sale open\");\n        _;\n    }\n\n    function isMintedOut() public view returns (bool) {\n        return _currentIndex == MAX_COBOTS;\n    }\n\n    modifier whenMintedOut() {\n        require(isMintedOut(), \"Co-Bots are not minted out\");\n        _;\n    }\n\n    modifier whenNotMintedOut() {\n        require(!isMintedOut(), \"Co-Bots are minted out\");\n        _;\n    }\n\n    ////////////////////////////////////////////////////////////////////////\n    ////////////////////////// Marketplaces ////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////\n    address public opensea;\n    address public looksrare;\n    mapping(address => bool) proxyToApproved;\n\n    /// @notice Set opensea to `opensea_`.\n    function setOpensea(address opensea_) external onlyOwner {\n        opensea = opensea_;\n    }\n\n    /// @notice Set looksrare to `looksrare_`.\n    function setLooksrare(address looksrare_) external onlyOwner {\n        looksrare = looksrare_;\n    }\n\n    /// @notice Approve the communication and interaction with cross-collection interactions.\n    function flipProxyState(address proxyAddress) public onlyOwner {\n        proxyToApproved[proxyAddress] = !proxyToApproved[proxyAddress];\n    }\n\n    /// @dev Modified for opensea and looksrare pre-approve.\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override(ERC721A)\n        returns (bool)\n    {\n        return\n            operator == address(ProxyRegistry(opensea).proxies(owner)) ||\n            operator == looksrare ||\n            proxyToApproved[operator] ||\n            super.isApprovedForAll(owner, operator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////\n    ////////////////////////// Token ///////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////\n    address public renderingContractAddress;\n    ICoBotsRenderer renderer;\n\n    function setRenderingContractAddress(address _renderingContractAddress)\n        public\n        onlyOwner\n    {\n        renderingContractAddress = _renderingContractAddress;\n        renderer = ICoBotsRenderer(renderingContractAddress);\n    }\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address _rendererAddress,\n        address _opensea,\n        address _looksrare,\n        address vrfCoordinator,\n        address link,\n        bytes32 keyHash\n    ) ERC721A(name_, symbol_) VRFConsumerBaseV2(vrfCoordinator) {\n        setRenderingContractAddress(_rendererAddress);\n        opensea = _opensea;\n        looksrare = _looksrare;\n        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n        LINKTOKEN = LinkTokenInterface(link);\n        gasKeyHash = keyHash;\n    }\n\n    function _mint(address to, uint256 quantity) internal {\n        require(quantity < 32, \"Too many Co-Bots to mint in one batch\");\n        bytes32 seeds = keccak256(\n            abi.encodePacked(\n                quantity,\n                msg.sender,\n                msg.value,\n                block.timestamp,\n                block.difficulty\n            )\n        );\n        for (uint256 i = 0; i < quantity; i++) {\n            uint256 tokenId = _currentIndex + i;\n            coBotsSeeds[tokenId] = uint8(seeds[i]);\n            coBotsColors[tokenId] = tokenId % 2 == 0;\n        }\n\n        _safeMint(to, quantity);\n    }\n\n    function mintPublicSale(uint256 quantity)\n        external\n        payable\n        whenPublicSaleOpen\n        nonReentrant\n    {\n        require(\n            msg.value == MINT_PUBLIC_PRICE * quantity,\n            \"Price does not match\"\n        );\n        require(\n            _currentIndex + quantity < MAX_COBOTS + 1,\n            \"There are not enough Co-Bots left to mint that amount\"\n        );\n        require(\n            ERC721A.balanceOf(_msgSender()) + quantity <= MAX_MINT_PER_ADDRESS,\n            \"Co-Bots: the requested quantity exceeds the maximum allowed\"\n        );\n\n        _mint(_msgSender(), quantity);\n    }\n\n    function mintFoundersAndGiveaways(address to, uint256 quantity)\n        external\n        onlyOwner\n    {\n        require(\n            quantity + _currentIndex <= MINT_FOUNDERS_AND_GIVEAWAYS,\n            \"Quantity exceeds founders and giveaways allowance\"\n        );\n\n        _mint(to, quantity);\n    }\n\n    function updateCooperativeRaffleStatus() internal {\n        if (\n            publicSaleStartTimestamp +\n                COBOTS_MINT_DURATION +\n                COBOTS_MINT_RAFFLE_DELAY >\n            block.timestamp &&\n            ((coBotsColorAgreement >= COORDINATION_RAFFLE_THRESHOLD) ||\n                (coBotsColorAgreement <=\n                    MAX_COBOTS - COORDINATION_RAFFLE_THRESHOLD))\n        ) {\n            cooperativeRaffleEnabled = true;\n        }\n    }\n\n    function toggleColor(uint256 tokenId) external nonReentrant {\n        require(\n            ERC721A.ownerOf(tokenId) == _msgSender(),\n            \"Only owner can toggle color\"\n        );\n\n        coBotsColors[tokenId] = !coBotsColors[tokenId];\n        unchecked {\n            coBotsColorAgreement = coBotsColors[tokenId]\n                ? coBotsColorAgreement + 1\n                : coBotsColorAgreement - 1;\n        }\n        updateCooperativeRaffleStatus();\n    }\n\n    function toggleColors(uint256[] calldata tokenIds) external nonReentrant {\n        bool commonColor = coBotsColors[tokenIds[0]];\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                ERC721A.ownerOf(tokenIds[i]) == _msgSender(),\n                \"Only owner can toggle color\"\n            );\n            require(\n                commonColor == coBotsColors[tokenIds[i]],\n                \"Toggling colors in two different colors!\"\n            );\n            coBotsColors[tokenIds[i]] = !coBotsColors[tokenIds[i]];\n        }\n        unchecked {\n            coBotsColorAgreement = commonColor\n                ? coBotsColorAgreement + uint16(tokenIds.length)\n                : coBotsColorAgreement - uint16(tokenIds.length);\n        }\n        updateCooperativeRaffleStatus();\n    }\n\n    function toggleStatus(uint256 tokenId) public nonReentrant {\n        require(\n            ERC721A.ownerOf(tokenId) == _msgSender(),\n            \"Only owner can toggle status\"\n        );\n\n        coBotsStatusDisabled[tokenId] = !coBotsStatusDisabled[tokenId];\n    }\n\n    function toggleStatuses(uint256[] calldata tokenIds) public nonReentrant {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            toggleStatus(tokenIds[i]);\n        }\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(_exists(_tokenId), \"ERC721: URI query for nonexistent token\");\n\n        if (renderingContractAddress == address(0)) {\n            return \"\";\n        }\n\n        return\n            renderer.tokenURI(\n                _tokenId,\n                coBotsSeeds[_tokenId],\n                !coBotsStatusDisabled[_tokenId],\n                coBotsColors[_tokenId]\n            );\n    }\n\n    function exists(uint256 _tokenId) external view returns (bool) {\n        return _exists(_tokenId);\n    }\n\n    receive() external payable {}\n\n    function withdraw() public onlyOwner {\n        require(\n            drawCount ==\n                (\n                    cooperativeRaffleEnabled\n                        ? MAIN_RAFFLE_WINNERS_COUNT +\n                            COORDINATION_RAFFLE_WINNERS_COUNT\n                        : MAIN_RAFFLE_WINNERS_COUNT\n                ) ||\n                (block.timestamp >\n                    publicSaleStartTimestamp +\n                        COBOTS_MINT_DURATION +\n                        COBOTS_REFUND_DURATION),\n            \"Dev cannot withdraw before the end of the game\"\n        );\n        (bool success, ) = _msgSender().call{value: address(this).balance}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    ////////////////////////////////////////////////////////////////////////\n    ////////////////////////// Raffle //////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////\n    VRFCoordinatorV2Interface COORDINATOR;\n    LinkTokenInterface LINKTOKEN;\n    bytes32 gasKeyHash;\n\n    uint256 public lastDrawTimestamp;\n    uint64 private s_subId;\n    mapping(address => uint256) public prizePerAddress;\n    address[] public winners;\n    mapping(uint256 => uint256) public prizePerDraw;\n    uint16 public drawCount;\n    bool public cooperativeRaffleEnabled;\n\n    function isDrawOpen() public view returns (bool) {\n        return\n            !isPublicSaleOpen() &&\n            block.timestamp >\n            publicSaleStartTimestamp +\n                COBOTS_MINT_DURATION +\n                COBOTS_MINT_RAFFLE_DELAY;\n    }\n\n    modifier whenDrawOpen() {\n        require(isDrawOpen(), \"Draw not active\");\n        _;\n    }\n\n    modifier whenRefundAllowed() {\n        require(\n            (block.timestamp >\n                publicSaleStartTimestamp + COBOTS_MINT_DURATION) &&\n                (block.timestamp <\n                    publicSaleStartTimestamp +\n                        COBOTS_MINT_DURATION +\n                        COBOTS_REFUND_DURATION),\n            \"Refund period not open\"\n        );\n        _;\n    }\n\n    function claimRefund()\n        external\n        nonReentrant\n        whenRefundAllowed\n        whenNotMintedOut\n    {\n        uint256 value;\n        for (uint256 i = 0; i < ERC721A.balanceOf(_msgSender()); i++) {\n            uint256 tokenId = ERC721A.tokenOfOwnerByIndex(_msgSender(), i);\n            if (tokenId < MINT_FOUNDERS_AND_GIVEAWAYS) {\n                continue;\n            }\n            if (!coBotsRefunded[tokenId]) {\n                value += MINT_PUBLIC_PRICE;\n                coBotsRefunded[tokenId] = true;\n            }\n        }\n        require(value > 0, \"No Co-Bots to refund\");\n        (bool success, ) = _msgSender().call{value: value}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    function claimRefund(uint256[] calldata tokenIds)\n        external\n        nonReentrant\n        whenRefundAllowed\n        whenNotMintedOut\n    {\n        uint256 value;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            if (tokenId < MINT_FOUNDERS_AND_GIVEAWAYS) {\n                continue;\n            }\n            require(\n                ERC721A.ownerOf(tokenId) == _msgSender(),\n                \"You cannot claim a refund for a token you do not own\"\n            );\n            if (!coBotsRefunded[tokenId]) {\n                value += MINT_PUBLIC_PRICE;\n                coBotsRefunded[tokenId] = true;\n            }\n        }\n        require(value > 0, \"No Co-Bots to refund\");\n        (bool success, ) = _msgSender().call{value: value}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    function createSubscriptionAndFund(uint96 amount) external onlyOwner {\n        if (s_subId == 0) {\n            s_subId = COORDINATOR.createSubscription();\n            COORDINATOR.addConsumer(s_subId, address(this));\n        }\n        LINKTOKEN.transferAndCall(\n            address(COORDINATOR),\n            amount,\n            abi.encode(s_subId)\n        );\n    }\n\n    function cancelSubscription() external onlyOwner {\n        COORDINATOR.cancelSubscription(s_subId, _msgSender());\n    }\n\n    function draw()\n        external\n        nonReentrant\n        whenDrawOpen\n        whenMintedOut\n        returns (uint256)\n    {\n        require(\n            drawCount <\n                (\n                    cooperativeRaffleEnabled\n                        ? MAIN_RAFFLE_WINNERS_COUNT +\n                            COORDINATION_RAFFLE_WINNERS_COUNT\n                        : MAIN_RAFFLE_WINNERS_COUNT\n                ),\n            \"Draw limit reached\"\n        );\n        require(\n            (lastDrawTimestamp + RAFFLE_DRAW_DELAY <= block.timestamp) ||\n                drawCount == 0,\n            \"Draws take place once per minute\"\n        );\n        lastDrawTimestamp = block.timestamp;\n        uint256 currentPrizeMoney = drawCount < MAIN_RAFFLE_WINNERS_COUNT\n            ? MAIN_RAFFLE_PRIZE\n            : COORDINATION_RAFFLE_PRIZE;\n        drawCount++;\n        uint256 requestId = COORDINATOR.requestRandomWords(\n            gasKeyHash,\n            s_subId,\n            5, // requestConfirmations\n            500_000, // callbackGasLimit\n            1 // numWords\n        );\n        prizePerDraw[requestId] = currentPrizeMoney;\n        return requestId;\n    }\n\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)\n        internal\n        override\n    {\n        uint256 selectedToken = randomWords[0];\n        address winner = ERC721A.ownerOf(selectedToken % 10_000);\n        while (\n            prizePerAddress[winner] > 0 ||\n            (selectedToken % 10_000 >= MINT_GIVEAWAYS &&\n                selectedToken % 10_000 < MINT_FOUNDERS_AND_GIVEAWAYS)\n        ) {\n            selectedToken = selectedToken >> 1;\n            winner = ERC721A.ownerOf(selectedToken % 10_000);\n        }\n        winners.push(winner);\n        prizePerAddress[winner] = prizePerDraw[requestId];\n        (bool success, ) = winner.call{value: prizePerDraw[requestId]}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "erc721a/contracts/ERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\nerror ApprovalCallerNotOwnerNorApproved();\nerror ApprovalQueryForNonexistentToken();\nerror ApproveToCaller();\nerror ApprovalToCurrentOwner();\nerror BalanceQueryForZeroAddress();\nerror MintedQueryForZeroAddress();\nerror BurnedQueryForZeroAddress();\nerror MintToZeroAddress();\nerror MintZeroQuantity();\nerror OwnerIndexOutOfBounds();\nerror OwnerQueryForNonexistentToken();\nerror TokenIndexOutOfBounds();\nerror TransferCallerNotOwnerNorApproved();\nerror TransferFromIncorrectOwner();\nerror TransferToNonERC721ReceiverImplementer();\nerror TransferToZeroAddress();\nerror URIQueryForNonexistentToken();\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata and Enumerable extension. Built to optimize for lower gas during batch mints.\n *\n * Assumes serials are sequentially minted starting at 0 (e.g. 0, 1, 2, 3..).\n *\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n *\n * Assumes that the maximum token id cannot exceed 2**128 - 1 (max value of uint128).\n */\ncontract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using Address for address;\n    using Strings for uint256;\n\n    // Compiler will pack this into a single 256bit word.\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n    }\n\n    // Compiler will pack this into a single 256bit word.\n    struct AddressData {\n        // Realistically, 2**64-1 is more than enough.\n        uint64 balance;\n        // Keeps track of mint count with minimal overhead for tokenomics.\n        uint64 numberMinted;\n        // Keeps track of burn count with minimal overhead for tokenomics.\n        uint64 numberBurned;\n    }\n\n    // Compiler will pack the following \n    // _currentIndex and _burnCounter into a single 256bit word.\n    \n    // The tokenId of the next token to be minted.\n    uint128 internal _currentIndex;\n\n    // The number of tokens burned.\n    uint128 internal _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) internal _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) private _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than _currentIndex times\n        unchecked {\n            return _currentIndex - _burnCounter;    \n        }\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     * This read function is O(totalSupply). If calling from a separate contract, be sure to test gas first.\n     * It may also degrade with extremely large collection sizes (e.g >> 10000), test for your use case.\n     */\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        uint256 numMintedSoFar = _currentIndex;\n        uint256 tokenIdsIdx;\n\n        // Counter overflow is impossible as the loop breaks when\n        // uint256 i is equal to another uint256 numMintedSoFar.\n        unchecked {\n            for (uint256 i; i < numMintedSoFar; i++) {\n                TokenOwnership memory ownership = _ownerships[i];\n                if (!ownership.burned) {\n                    if (tokenIdsIdx == index) {\n                        return i;\n                    }\n                    tokenIdsIdx++;\n                }\n            }\n        }\n        revert TokenIndexOutOfBounds();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     * This read function is O(totalSupply). If calling from a separate contract, be sure to test gas first.\n     * It may also degrade with extremely large collection sizes (e.g >> 10000), test for your use case.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        if (index >= balanceOf(owner)) revert OwnerIndexOutOfBounds();\n        uint256 numMintedSoFar = _currentIndex;\n        uint256 tokenIdsIdx;\n        address currOwnershipAddr;\n\n        // Counter overflow is impossible as the loop breaks when\n        // uint256 i is equal to another uint256 numMintedSoFar.\n        unchecked {\n            for (uint256 i; i < numMintedSoFar; i++) {\n                TokenOwnership memory ownership = _ownerships[i];\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    if (tokenIdsIdx == index) {\n                        return i;\n                    }\n                    tokenIdsIdx++;\n                }\n            }\n        }\n\n        // Execution should never reach this point.\n        revert();\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }\n\n    function _numberMinted(address owner) internal view returns (uint256) {\n        if (owner == address(0)) revert MintedQueryForZeroAddress();\n        return uint256(_addressData[owner].numberMinted);\n    }\n\n    function _numberBurned(address owner) internal view returns (uint256) {\n        if (owner == address(0)) revert BurnedQueryForZeroAddress();\n        return uint256(_addressData[owner].numberBurned);\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (curr < _currentIndex) {\n                TokenOwnership memory ownership = _ownerships[curr];\n                if (!ownership.burned) {\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                    // Invariant: \n                    // There will always be an ownership that has an address and is not burned \n                    // before an ownership that does not have an address and is not burned.\n                    // Hence, curr will not underflow.\n                    while (true) {\n                        curr--;\n                        ownership = _ownerships[curr];\n                        if (ownership.addr != address(0)) {\n                            return ownership;\n                        }\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ERC721A.ownerOf(tokenId);\n        if (to == owner) revert ApprovalToCurrentOwner();\n\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public override {\n        if (operator == _msgSender()) revert ApproveToCaller();\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return tokenId < _currentIndex && !_ownerships[tokenId].burned;\n    }\n\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, '');\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        _mint(to, quantity, _data, true);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 3.4e38 (2**128) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 3.4e38 (2**128) - 1\n        unchecked {\n            _addressData[to].balance += uint64(quantity);\n            _addressData[to].numberMinted += uint64(quantity);\n\n            _ownerships[startTokenId].addr = to;\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n\n            for (uint256 i; i < quantity; i++) {\n                emit Transfer(address(0), to, updatedIndex);\n                if (safe && !_checkOnERC721Received(address(0), to, updatedIndex, _data)) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                }\n                updatedIndex++;\n            }\n\n            _currentIndex = uint128(updatedIndex);\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\n\n        bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||\n            isApprovedForAll(prevOwnership.addr, _msgSender()) ||\n            getApproved(tokenId) == _msgSender());\n\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, prevOwnership.addr);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**128.\n        unchecked {\n            _addressData[from].balance -= 1;\n            _addressData[to].balance += 1;\n\n            _ownerships[tokenId].addr = to;\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (_ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < _currentIndex) {\n                    _ownerships[nextTokenId].addr = prevOwnership.addr;\n                    _ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\n\n        _beforeTokenTransfers(prevOwnership.addr, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, prevOwnership.addr);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**128.\n        unchecked {\n            _addressData[prevOwnership.addr].balance -= 1;\n            _addressData[prevOwnership.addr].numberBurned += 1;\n\n            // Keep track of who burned the token, and the timestamp of burning.\n            _ownerships[tokenId].addr = prevOwnership.addr;\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n            _ownerships[tokenId].burned = true;\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (_ownerships[nextTokenId].addr == address(0)) {\n                // This will suffice for checking _exists(nextTokenId),\n                // as a burned slot cannot contain the zero address.\n                if (nextTokenId < _currentIndex) {\n                    _ownerships[nextTokenId].addr = prevOwnership.addr;\n                    _ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(prevOwnership.addr, address(0), tokenId);\n        _afterTokenTransfers(prevOwnership.addr, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked { \n            _burnCounter++;\n        }\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert TransferToNonERC721ReceiverImplementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}\n"
    },
    "contracts/interfaces/ICoBotsRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\ninterface ICoBotsRenderer {\n    function tokenURI(\n        uint256 tokenId,\n        uint8 seed,\n        bool status,\n        bool color\n    ) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/co-bots/CoBotsRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@0xsequence/sstore2/contracts/SSTORE2.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport {Integers} from \"../lib/Integers.sol\";\nimport \"../interfaces/ICoBotsRenderer.sol\";\n\n/*  @title CoBots Renderer\n    @author Clement Walter\n    @dev Encode each traits as a \"sum\" of `rect`, each rect being stored using 4 bytes\n*/\ncontract CoBotsRenderer is Ownable, ReentrancyGuard, ICoBotsRenderer {\n    using Integers for uint8;\n    using Strings for uint256;\n\n    // We have a total of 4 * 6 = 24 bits = 3 bytes for coordinates + 1 byte for the color\n    // Hence each rect is 4 bytes\n    uint8 public constant BITS_PER_COORDINATES = 6;\n    uint8 public constant BITS_PER_FILL_INDEX = 8;\n\n    string public constant RECT_TAG_START = \"%3crect%20x=%27\";\n    string public constant Y_TAG = \"%27%20y=%27\";\n    string public constant WIDTH_TAG = \"%27%20width=%27\";\n    string public constant HEIGHT_TAG = \"%27%20height=%27\";\n    string public constant FILL_TAG = \"%27%20fill=%27%23\";\n    string public constant RECT_TAG_END = \"%27/%3e\";\n    string public constant SVG_TAG_START =\n        \"%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20viewBox=%270%200%2045%2045%27%20width=%27450px%27%20height=%27450px%27%3e\";\n    string public constant SVG_TAG_END =\n        \"%3cstyle%3erect{shape-rendering:crispEdges}%3c/style%3e%3c/svg%3e\";\n\n    address public fillPalette;\n    address public traitPalette;\n    address public traitPaletteIndexes; // where each trait begins in the traits' palette\n    bytes public layerIndexes; // the index of the first item of each layer, uint8/bytes1 for each layer\n\n    ////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////  Rendering mechanics  /////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////\n    /// @dev Colors are concatenated and stored in a single 'bytes' with SSTORE2 to save gas.\n    function setFillPalette(bytes calldata _fillPalette) external onlyOwner {\n        fillPalette = SSTORE2.write(_fillPalette);\n    }\n\n    /// @dev All the rects are concatenated together to save gas.\n    ///      The traitPaletteIndexes is used to retrieve the rect from the traitPalette.\n    function setTraitPalette(bytes calldata _traitPalette) external onlyOwner {\n        traitPalette = SSTORE2.write(_traitPalette);\n    }\n\n    /// @dev Since each SSTORE2 slots can contain up to 24kb, indexes need to be uint16, ie. two bytes per index.\n    function setTraitPaletteIndexes(bytes calldata _traitPaletteIndexes)\n        external\n        onlyOwner\n    {\n        traitPaletteIndexes = SSTORE2.write(_traitPaletteIndexes);\n    }\n\n    /// @dev Traits are stored as a plain list while the rendering works with layer and items within each layer.\n    ///      Since each layer has a variable number of items, we store the index of the first trait of each layer.\n    function setLayerIndexes(bytes calldata _layerIndexes) external onlyOwner {\n        layerIndexes = _layerIndexes;\n    }\n\n    /// @dev 3 bytes per color because svg does not handle alpha.\n    function getFill(uint256 _index) public view returns (string memory) {\n        bytes memory palette = SSTORE2.read(fillPalette);\n        return\n            string.concat(\n                uint8(palette[3 * _index]).toString(16, 2),\n                uint8(palette[3 * _index + 1]).toString(16, 2),\n                uint8(palette[3 * _index + 2]).toString(16, 2)\n            );\n    }\n\n    /// @dev This function lets map from layerIndex and itemIndex to traitIndex.\n    function getTraitIndex(uint256 _layerIndex, uint256 _itemIndex)\n        public\n        view\n        returns (uint256)\n    {\n        uint8 traitIndex = uint8(layerIndexes[_layerIndex]);\n        uint8 nextTraitIndex = uint8(layerIndexes[_layerIndex + 1]);\n        if (traitIndex + _itemIndex > nextTraitIndex - 1) {\n            return type(uint8).max;\n        }\n\n        return _itemIndex + traitIndex;\n    }\n\n    /// @dev Retrieve the bytes for the given trait from the traitPalette storage.\n    function getTraitBytes(uint256 _index) public view returns (bytes memory) {\n        bytes memory _indexes = SSTORE2.read(traitPaletteIndexes);\n        uint32 start = uint32(BytesLib.toUint16(_indexes, _index * 2));\n        uint32 next = uint32(BytesLib.toUint16(_indexes, _index * 2 + 2));\n        bytes memory _traitPalette = SSTORE2.read(traitPalette);\n        return BytesLib.slice(_traitPalette, start, next - start);\n    }\n\n    function decodeRect(bytes memory rectBytes)\n        public\n        view\n        returns (string memory)\n    {\n        return decodeRect(rectBytes, 0, 0);\n    }\n\n    function decodeRect(\n        bytes memory rectBytes,\n        uint8 offsetX,\n        uint8 offsetY\n    ) public view returns (string memory) {\n        require(rectBytes.length == 4, \"Rect bytes must be 4 bytes long\");\n        string memory fill = getFill(uint8(rectBytes[3]));\n        return\n            string.concat(\n                RECT_TAG_START,\n                (uint8(rectBytes[0] >> 2) + offsetX).toString(),\n                Y_TAG,\n                (uint8(((rectBytes[0] << 4) | (rectBytes[1] >> 4)) & 0x3f) +\n                    offsetY).toString(),\n                WIDTH_TAG,\n                uint8(((rectBytes[1] << 2) & 0x3f) | (rectBytes[2] >> 6))\n                    .toString(),\n                HEIGHT_TAG,\n                uint8(rectBytes[2] & 0x3f).toString(),\n                FILL_TAG,\n                fill,\n                RECT_TAG_END\n            );\n    }\n\n    function decode8Rects(bytes32 rectsBytes)\n        public\n        view\n        returns (string memory)\n    {\n        return\n            string.concat(\n                decodeRect(\n                    bytes.concat(\n                        rectsBytes[0],\n                        rectsBytes[1],\n                        rectsBytes[2],\n                        rectsBytes[3]\n                    )\n                ),\n                decodeRect(\n                    bytes.concat(\n                        rectsBytes[4],\n                        rectsBytes[5],\n                        rectsBytes[6],\n                        rectsBytes[7]\n                    )\n                ),\n                decodeRect(\n                    bytes.concat(\n                        rectsBytes[8],\n                        rectsBytes[9],\n                        rectsBytes[10],\n                        rectsBytes[11]\n                    )\n                ),\n                decodeRect(\n                    bytes.concat(\n                        rectsBytes[12],\n                        rectsBytes[13],\n                        rectsBytes[14],\n                        rectsBytes[15]\n                    )\n                ),\n                decodeRect(\n                    bytes.concat(\n                        rectsBytes[16],\n                        rectsBytes[17],\n                        rectsBytes[18],\n                        rectsBytes[19]\n                    )\n                ),\n                decodeRect(\n                    bytes.concat(\n                        rectsBytes[20],\n                        rectsBytes[21],\n                        rectsBytes[22],\n                        rectsBytes[23]\n                    )\n                ),\n                decodeRect(\n                    bytes.concat(\n                        rectsBytes[24],\n                        rectsBytes[25],\n                        rectsBytes[26],\n                        rectsBytes[27]\n                    )\n                ),\n                decodeRect(\n                    bytes.concat(\n                        rectsBytes[28],\n                        rectsBytes[29],\n                        rectsBytes[30],\n                        rectsBytes[31]\n                    )\n                )\n            );\n    }\n\n    function decode32Rects(bytes memory rectsBytes)\n        public\n        view\n        returns (string memory)\n    {\n        return\n            string.concat(\n                decode8Rects(BytesLib.toBytes32(rectsBytes, 0)),\n                decode8Rects(BytesLib.toBytes32(rectsBytes, 32)),\n                decode8Rects(BytesLib.toBytes32(rectsBytes, 64)),\n                decode8Rects(BytesLib.toBytes32(rectsBytes, 96))\n            );\n    }\n\n    /// @dev Decode the rect and returns it as a plain string to be used in the svg rect attribute.\n    ///      One rect is 4 bytes so 8 rects is a bytes32.\n    ///      With 20 bytes32, we have up to 160 rects per trait / co-bots actually if we concat the bytes first.\n    ///      This magic number comes from a small data analysis of the traits. We use the fact that an empty\n    ///      bytes32 will lead to an empty rect (width and height 0).\n    function getTrait(bytes memory traitEncodedBytes)\n        public\n        view\n        returns (string memory)\n    {\n        // buffer is 20 * 32 bytes = up to 160 rects\n        bytes memory buffer = bytes.concat(\n            traitEncodedBytes,\n            new bytes(640 - traitEncodedBytes.length)\n        );\n        return\n            string.concat(\n                SVG_TAG_START,\n                decode32Rects(BytesLib.slice(buffer, 0, 128)),\n                decode32Rects(BytesLib.slice(buffer, 128, 128)),\n                decode32Rects(BytesLib.slice(buffer, 256, 128)),\n                decode32Rects(BytesLib.slice(buffer, 384, 128)),\n                decode32Rects(BytesLib.slice(buffer, 512, 128)),\n                SVG_TAG_END\n            );\n    }\n\n    function getImageURI(bytes memory traitEncodedBytes)\n        public\n        view\n        returns (string memory)\n    {\n        return\n            string.concat(\"data:image/svg+xml,\", getTrait(traitEncodedBytes));\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////  Co-bots  ////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function getRandomItems(uint256 tokenId, uint8 seed)\n        public\n        pure\n        returns (\n            uint256 eyesIndex,\n            uint256 mouthIndex,\n            uint256 antennaIndex,\n            uint256 feetIndex\n        )\n    {\n        uint256 randomBotMemory = uint256(\n            keccak256(abi.encodePacked(tokenId, seed))\n        );\n\n        // Eyes\n        uint256 randomEyes = randomBotMemory % 10_000;\n        randomBotMemory >>= 14;\n        eyesIndex = randomEyes < 25\n            ? 11\n            : (randomEyes < 75 ? 10 : randomEyes % 10);\n\n        // Mouth\n        uint256 randomMouth = randomBotMemory % 10_000;\n        randomBotMemory >>= 14;\n        mouthIndex = randomMouth < 50 ? 10 : randomMouth % 10;\n\n        // Antenna\n        uint256 randomAntenna = randomBotMemory % 10_000;\n        randomBotMemory >>= 14;\n        antennaIndex = randomAntenna < 50\n            ? 10\n            : (randomAntenna < 75 ? 11 : randomAntenna % 10);\n\n        // Feet\n        uint256 randomFeet = randomBotMemory % 10_000;\n        randomBotMemory >>= 14;\n        feetIndex = randomFeet < 50 ? 10 : randomFeet % 10;\n    }\n\n    function getToadItems()\n        public\n        pure\n        returns (\n            uint256 eyesIndex,\n            uint256 mouthIndex,\n            uint256 antennaIndex,\n            uint256 feetIndex\n        )\n    {\n        return (0, 0, 12, 6);\n    }\n\n    function getNounishItems()\n        public\n        pure\n        returns (\n            uint256 eyesIndex,\n            uint256 mouthIndex,\n            uint256 antennaIndex,\n            uint256 feetIndex\n        )\n    {\n        return (0, 0, 13, 0);\n    }\n\n    function getWizardItems()\n        public\n        pure\n        returns (\n            uint256 eyesIndex,\n            uint256 mouthIndex,\n            uint256 antennaIndex,\n            uint256 feetIndex\n        )\n    {\n        return (0, 0, 14, 9);\n    }\n\n    function getCoBotItems(\n        uint256 tokenId,\n        uint8 seed,\n        bool status,\n        bool color\n    ) public pure returns (uint256[10] memory) {\n        uint256 eyesIndex;\n        uint256 mouthIndex;\n        uint256 antennaIndex;\n        uint256 feetIndex;\n        if (tokenId == 0) {\n            (\n                eyesIndex,\n                mouthIndex,\n                antennaIndex,\n                feetIndex\n            ) = getNounishItems();\n        } else if (tokenId == 1) {\n            (eyesIndex, mouthIndex, antennaIndex, feetIndex) = getToadItems();\n        } else if (tokenId == 2) {\n            (eyesIndex, mouthIndex, antennaIndex, feetIndex) = getWizardItems();\n        } else {\n            (eyesIndex, mouthIndex, antennaIndex, feetIndex) = getRandomItems(\n                tokenId,\n                seed\n            );\n        }\n\n        uint256[10] memory items;\n        // 0. Colour\n        items[0] = color ? 0 : 1;\n        // 1. Digit 1\n        items[1] = tokenId / 1000;\n        // 2. Digit 2\n        items[2] = (tokenId / 100) % 10;\n        // 3. Digit 3\n        items[3] = (tokenId / 10) % 10;\n        // 4. Digit 4\n        items[4] = tokenId % 10;\n        // 5. Eyes\n        items[5] = eyesIndex;\n        // 6. Mouth\n        items[6] = mouthIndex;\n        // 7. Antenna\n        items[7] = antennaIndex;\n        // 8. Status\n        items[8] = status ? 1 : 0;\n        // 9. Feet\n        items[9] = feetIndex;\n        return items;\n    }\n\n    function getCoBotBytes(uint256[10] memory items)\n        public\n        view\n        returns (bytes memory)\n    {\n        return\n            bytes.concat(\n                getTraitBytes(getTraitIndex(0, items[0])),\n                getTraitBytes(getTraitIndex(1, items[1])),\n                getTraitBytes(getTraitIndex(2, items[2])),\n                getTraitBytes(getTraitIndex(3, items[3])),\n                getTraitBytes(getTraitIndex(4, items[4])),\n                getTraitBytes(getTraitIndex(5, items[5])),\n                getTraitBytes(getTraitIndex(6, items[6])),\n                getTraitBytes(getTraitIndex(7, items[7])),\n                items[8] == 1\n                    ? new bytes(4)\n                    : getTraitBytes(getTraitIndex(8, items[8])),\n                getTraitBytes(getTraitIndex(9, items[9]))\n            );\n    }\n\n    function getCoBotImageURI(uint256[10] memory items)\n        public\n        view\n        returns (string memory)\n    {\n        return getImageURI(getCoBotBytes(items));\n    }\n\n    function getCoBotAttributes(\n        uint256[10] memory items,\n        bool status,\n        bool color\n    ) public pure returns (string memory) {\n        string[12] memory eyes = [\n            \"Classic\", // 0\n            \"Cyclops\", // 1\n            \"Awoken\", // 2\n            \"Flirty\", // 3\n            \"Zen\", // 4\n            \"Sadhappy\", // 5\n            \"Unaligned\", // 6\n            \"Smitten\", // 7\n            \"Optimistic\", // 8\n            \"Hacky\", // 9\n            \"Super\", // 50 times\n            \"Nounish\" // 25 times\n        ];\n        string[11] memory mouths = [\n            \"Classic\", // 0\n            \"Worried\", // 1\n            \"Knightly\", // 2\n            \"Shy\", // 3\n            \"Happy\", // 4\n            \"Bigsad\", // 5\n            \"Smug\", // 6\n            \"Wowed\", // 7\n            \"Thirsty\", // 8\n            \"Villainous\", // 9\n            \"Shady\" // 50 times\n        ];\n        string[15] memory antennas = [\n            \"Classic\", // 0\n            \"Serious\", // 1\n            \"Jumpy\", // 2\n            \"Buzzed\", // 3\n            \"Buggy\", // 4\n            \"Punk\", // 5\n            \"Angelic\", // 6\n            \"Impish\", // 7\n            \"Humbled\", // 8\n            \"Western\", // 9\n            \"Royal\", // 50 times\n            \"Hacky\", // 25 times\n            \"!croak\", // 1 time for tokeId 69\n            \"Nounish\", // 1 time for tokeId 420\n            \"Wizard\" // 1 time for tokeId 777\n        ];\n        string[11] memory feet = [\n            \"Classic\", // 0\n            \"Heavy Duty\", // 1\n            \"Firey\", // 2\n            \"Little Firey\", // 3\n            \"Roller\", // 4\n            \"Little Roller\", // 5\n            \"Energetic\", // 6\n            \"Little Energetic\", // 7\n            \"Hobbled\", // 8\n            \"Ghostly\", // 9\n            \"Pushy\" // 50 times\n        ];\n        return\n            string.concat(\n                \"[\",\n                items[7] > 11 ? \"\" : '{\"trait_type\": \"Eyes\", \"value\": \"',\n                items[7] > 11 ? \"\" : eyes[items[5]],\n                items[7] > 11 ? \"\" : '\"},',\n                items[7] > 11 ? \"\" : '{\"trait_type\": \"Mouth\", \"value\": \"',\n                items[7] > 11 ? \"\" : mouths[items[6]],\n                items[7] > 11 ? \"\" : '\"},',\n                '{\"trait_type\": \"Antenna\", \"value\": \"',\n                antennas[items[7]],\n                '\"},',\n                '{\"trait_type\": \"Feet\", \"value\": \"',\n                feet[items[9]],\n                '\"},',\n                '{\"trait_type\": \"Status\", \"value\": \"',\n                status ? \"Online\" : \"Offline\",\n                '\"},',\n                '{\"trait_type\": \"Color\", \"value\": \"',\n                color ? \"Blue\" : \"Red\",\n                '\"}',\n                \"]\"\n            );\n    }\n\n    function tokenURI(\n        uint256 tokenId,\n        uint8 seed,\n        bool status,\n        bool color\n    ) public view returns (string memory) {\n        uint256[10] memory items = getCoBotItems(tokenId, seed, status, color);\n        return\n            string.concat(\n                \"data:application/json,\",\n                '{\"image_data\": \"',\n                getCoBotImageURI(items),\n                '\"',\n                ',\"description\": \"Co-Bots are cooperation robots. CC0 & 100% On-Chain. co-bots.com.\"',\n                ',\"name\": \"Co-Bot #',\n                tokenId.toString(),\n                '\"',\n                ',\"attributes\": ',\n                getCoBotAttributes(items, status, color),\n                \"}\"\n            );\n    }\n}\n"
    },
    "@0xsequence/sstore2/contracts/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./utils/Bytecode.sol\";\n\n/**\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\n  @author Agustin Aguilar <aa@horizon.io>\n\n  Readme: https://github.com/0xsequence/sstore2#readme\n*/\nlibrary SSTORE2 {\n  error WriteError();\n\n  /**\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `_data` as code\n    @param _data to be written\n    @return pointer Pointer to the written `_data`\n  */\n  function write(bytes memory _data) internal returns (address pointer) {\n    // Append 00 to _data so contract can't be called\n    // Build init code\n    bytes memory code = Bytecode.creationCodeFor(\n      abi.encodePacked(\n        hex'00',\n        _data\n      )\n    );\n\n    // Deploy contract using create\n    assembly { pointer := create(0, add(code, 32), mload(code)) }\n\n    // Address MUST be non-zero\n    if (pointer == address(0)) revert WriteError();\n  }\n\n  /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @return data read from `_pointer` contract\n  */\n  function read(address _pointer) internal view returns (bytes memory) {\n    return Bytecode.codeAt(_pointer, 1, type(uint256).max);\n  }\n\n  /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @return data read from `_pointer` contract\n  */\n  function read(address _pointer, uint256 _start) internal view returns (bytes memory) {\n    return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\n  }\n\n  /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @param _end index before which to end extraction\n    @return data read from `_pointer` contract\n  */\n  function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {\n    return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\n  }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/lib/Integers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * Integers Library updated from https://github.com/willitscale/solidity-util\n *\n * In summary this is a simple library of integer functions which allow a simple\n * conversion to and from strings\n *\n * @author Clement Walter <clement0walter@gmail.com>\n */\nlibrary Integers {\n    /**\n     * To String\n     *\n     * Converts an unsigned integer to the string equivalent value, returned as bytes\n     * Equivalent to javascript's toString(base)\n     *\n     * @param _number The unsigned integer to be converted to a string\n     * @param _base The base to convert the number to\n     * @param  _padding The target length of the string; result will be padded with 0 to reach this length while padding\n     *         of 0 means no padding\n     * @return bytes The resulting ASCII string value\n     */\n    function toString(\n        uint256 _number,\n        uint8 _base,\n        uint8 _padding\n    ) public pure returns (string memory) {\n        uint256 count = 0;\n        uint256 b = _number;\n        while (b != 0) {\n            count++;\n            b /= _base;\n        }\n        if (_number == 0) {\n            count++;\n        }\n        bytes memory res;\n        if (_padding == 0) {\n            res = new bytes(count);\n        } else {\n            res = new bytes(_padding);\n        }\n        for (uint256 i = 0; i < count; ++i) {\n            b = _number % _base;\n            if (b < 10) {\n                res[res.length - i - 1] = bytes1(uint8(b + 48)); // 0-9\n            } else {\n                res[res.length - i - 1] = bytes1(uint8((b % 10) + 65)); // A-F\n            }\n            _number /= _base;\n        }\n\n        for (uint256 i = count; i < _padding; ++i) {\n            res[res.length - i - 1] = hex\"30\"; // 0\n        }\n\n        return string(res);\n    }\n\n    function toString(uint256 _number) public pure returns (string memory) {\n        return toString(_number, 10, 0);\n    }\n\n    function toString(uint256 _number, uint8 _base)\n        public\n        pure\n        returns (string memory)\n    {\n        return toString(_number, _base, 0);\n    }\n\n    /**\n     * Load 16\n     *\n     * Converts two bytes to a 16 bit unsigned integer\n     *\n     * @param _leadingBytes the first byte of the unsigned integer in [256, 65536]\n     * @param _endingBytes the second byte of the unsigned integer in [0, 255]\n     * @return uint16 The resulting integer value\n     */\n    function load16(bytes1 _leadingBytes, bytes1 _endingBytes)\n        public\n        pure\n        returns (uint16)\n    {\n        return\n            (uint16(uint8(_leadingBytes)) << 8) + uint16(uint8(_endingBytes));\n    }\n\n    /**\n     * Load 12\n     *\n     * Converts three bytes into two uint12 integers\n     *\n     * @return (uint16, uint16) The two uint16 values up to 2^12 each\n     */\n    function load12x2(\n        bytes1 first,\n        bytes1 second,\n        bytes1 third\n    ) public pure returns (uint16, uint16) {\n        return (\n            (uint16(uint8(first)) << 4) + (uint16(uint8(second)) >> 4),\n            (uint16(uint8(second & hex\"0f\")) << 8) + uint16(uint8(third))\n        );\n    }\n}\n"
    },
    "@0xsequence/sstore2/contracts/utils/Bytecode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nlibrary Bytecode {\n  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\n\n  /**\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\n    @param _code The returning value of the resulting `creationCode`\n    @return creationCode (constructor) for new contract\n  */\n  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\n    /*\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\n      0x01    0x80         0x80        DUP1                size size\n      0x02    0x60         0x600e      PUSH1 14            14 size size\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\n      0x04    0x39         0x39        CODECOPY            size\n      0x05    0x60         0x6000      PUSH1 00            0 size\n      0x06    0xf3         0xf3        RETURN\n      <CODE>\n    */\n\n    return abi.encodePacked(\n      hex\"63\",\n      uint32(_code.length),\n      hex\"80_60_0E_60_00_39_60_00_F3\",\n      _code\n    );\n  }\n\n  /**\n    @notice Returns the size of the code on a given address\n    @param _addr Address that may or may not contain code\n    @return size of the code on the given `_addr`\n  */\n  function codeSize(address _addr) internal view returns (uint256 size) {\n    assembly { size := extcodesize(_addr) }\n  }\n\n  /**\n    @notice Returns the code of a given address\n    @dev It will fail if `_end < _start`\n    @param _addr Address that may or may not contain code\n    @param _start number of bytes of code to skip on read\n    @param _end index before which to end extraction\n    @return oCode read from `_addr` deployed bytecode\n\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\n  */\n  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {\n    uint256 csize = codeSize(_addr);\n    if (csize == 0) return bytes(\"\");\n\n    if (_start > csize) return bytes(\"\");\n    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); \n\n    unchecked {\n      uint256 reqSize = _end - _start;\n      uint256 maxSize = csize - _start;\n\n      uint256 size = maxSize < reqSize ? maxSize : reqSize;\n\n      assembly {\n        // allocate output byte array - this could also be done without assembly\n        // by using o_code = new bytes(size)\n        oCode := mload(0x40)\n        // new \"memory end\" including padding\n        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n        // store length in memory\n        mstore(oCode, size)\n        // actually retrieve the code, this needs assembly\n        extcodecopy(_addr, add(oCode, 0x20), _start, size)\n      }\n    }\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/dev/VRFCoordinatorV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/BlockhashStoreInterface.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../interfaces/TypeAndVersionInterface.sol\";\nimport \"../interfaces/ERC677ReceiverInterface.sol\";\nimport \"./VRF.sol\";\nimport \"../ConfirmedOwner.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\n\ncontract VRFCoordinatorV2 is\n  VRF,\n  ConfirmedOwner,\n  TypeAndVersionInterface,\n  VRFCoordinatorV2Interface,\n  ERC677ReceiverInterface\n{\n  LinkTokenInterface public immutable LINK;\n  AggregatorV3Interface public immutable LINK_ETH_FEED;\n  BlockhashStoreInterface public immutable BLOCKHASH_STORE;\n\n  // We need to maintain a list of consuming addresses.\n  // This bound ensures we are able to loop over them as needed.\n  // Should a user require more consumers, they can use multiple subscriptions.\n  uint16 public constant MAX_CONSUMERS = 100;\n  error TooManyConsumers();\n  error InsufficientBalance();\n  error InvalidConsumer(uint64 subId, address consumer);\n  error InvalidSubscription();\n  error OnlyCallableFromLink();\n  error InvalidCalldata();\n  error MustBeSubOwner(address owner);\n  error PendingRequestExists();\n  error MustBeRequestedOwner(address proposedOwner);\n  error BalanceInvariantViolated(uint256 internalBalance, uint256 externalBalance); // Should never happen\n  event FundsRecovered(address to, uint256 amount);\n  // We use the subscription struct (1 word)\n  // at fulfillment time.\n  struct Subscription {\n    // There are only 1e9*1e18 = 1e27 juels in existence, so the balance can fit in uint96 (2^96 ~ 7e28)\n    uint96 balance; // Common link balance used for all consumer requests.\n    uint64 reqCount; // For fee tiers\n  }\n  // We use the config for the mgmt APIs\n  struct SubscriptionConfig {\n    address owner; // Owner can fund/withdraw/cancel the sub.\n    address requestedOwner; // For safely transferring sub ownership.\n    // Maintains the list of keys in s_consumers.\n    // We do this for 2 reasons:\n    // 1. To be able to clean up all keys from s_consumers when canceling a subscription.\n    // 2. To be able to return the list of all consumers in getSubscription.\n    // Note that we need the s_consumers map to be able to directly check if a\n    // consumer is valid without reading all the consumers from storage.\n    address[] consumers;\n  }\n  // Note a nonce of 0 indicates an the consumer is not assigned to that subscription.\n  mapping(address => mapping(uint64 => uint64)) /* consumer */ /* subId */ /* nonce */\n    private s_consumers;\n  mapping(uint64 => SubscriptionConfig) /* subId */ /* subscriptionConfig */\n    private s_subscriptionConfigs;\n  mapping(uint64 => Subscription) /* subId */ /* subscription */\n    private s_subscriptions;\n  // We make the sub count public so that its possible to\n  // get all the current subscriptions via getSubscription.\n  uint64 private s_currentSubId;\n  // s_totalBalance tracks the total link sent to/from\n  // this contract through onTokenTransfer, cancelSubscription and oracleWithdraw.\n  // A discrepancy with this contract's link balance indicates someone\n  // sent tokens using transfer and so we may need to use recoverFunds.\n  uint96 private s_totalBalance;\n  event SubscriptionCreated(uint64 indexed subId, address owner);\n  event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\n  event SubscriptionConsumerAdded(uint64 indexed subId, address consumer);\n  event SubscriptionConsumerRemoved(uint64 indexed subId, address consumer);\n  event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\n  event SubscriptionOwnerTransferRequested(uint64 indexed subId, address from, address to);\n  event SubscriptionOwnerTransferred(uint64 indexed subId, address from, address to);\n\n  // Set this maximum to 200 to give us a 56 block window to fulfill\n  // the request before requiring the block hash feeder.\n  uint16 public constant MAX_REQUEST_CONFIRMATIONS = 200;\n  uint32 public constant MAX_NUM_WORDS = 500;\n  // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\n  // and some arithmetic operations.\n  uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n  error InvalidRequestConfirmations(uint16 have, uint16 min, uint16 max);\n  error GasLimitTooBig(uint32 have, uint32 want);\n  error NumWordsTooBig(uint32 have, uint32 want);\n  error ProvingKeyAlreadyRegistered(bytes32 keyHash);\n  error NoSuchProvingKey(bytes32 keyHash);\n  error InvalidLinkWeiPrice(int256 linkWei);\n  error InsufficientGasForConsumer(uint256 have, uint256 want);\n  error NoCorrespondingRequest();\n  error IncorrectCommitment();\n  error BlockhashNotInStore(uint256 blockNum);\n  error PaymentTooLarge();\n  error Reentrant();\n  struct RequestCommitment {\n    uint64 blockNum;\n    uint64 subId;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    address sender;\n  }\n  mapping(bytes32 => address) /* keyHash */ /* oracle */\n    private s_provingKeys;\n  bytes32[] private s_provingKeyHashes;\n  mapping(address => uint96) /* oracle */ /* LINK balance */\n    private s_withdrawableTokens;\n  mapping(uint256 => bytes32) /* requestID */ /* commitment */\n    private s_requestCommitments;\n  event ProvingKeyRegistered(bytes32 keyHash, address indexed oracle);\n  event ProvingKeyDeregistered(bytes32 keyHash, address indexed oracle);\n  event RandomWordsRequested(\n    bytes32 indexed keyHash,\n    uint256 requestId,\n    uint256 preSeed,\n    uint64 indexed subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords,\n    address indexed sender\n  );\n  event RandomWordsFulfilled(uint256 indexed requestId, uint256 outputSeed, uint96 payment, bool success);\n\n  struct Config {\n    uint16 minimumRequestConfirmations;\n    uint32 maxGasLimit;\n    // Reentrancy protection.\n    bool reentrancyLock;\n    // stalenessSeconds is how long before we consider the feed price to be stale\n    // and fallback to fallbackWeiPerUnitLink.\n    uint32 stalenessSeconds;\n    // Gas to cover oracle payment after we calculate the payment.\n    // We make it configurable in case those operations are repriced.\n    uint32 gasAfterPaymentCalculation;\n  }\n  int256 private s_fallbackWeiPerUnitLink;\n  Config private s_config;\n  FeeConfig private s_feeConfig;\n  struct FeeConfig {\n    // Flat fee charged per fulfillment in millionths of link\n    // So fee range is [0, 2^32/10^6].\n    uint32 fulfillmentFlatFeeLinkPPMTier1;\n    uint32 fulfillmentFlatFeeLinkPPMTier2;\n    uint32 fulfillmentFlatFeeLinkPPMTier3;\n    uint32 fulfillmentFlatFeeLinkPPMTier4;\n    uint32 fulfillmentFlatFeeLinkPPMTier5;\n    uint24 reqsForTier2;\n    uint24 reqsForTier3;\n    uint24 reqsForTier4;\n    uint24 reqsForTier5;\n  }\n  event ConfigSet(\n    uint16 minimumRequestConfirmations,\n    uint32 maxGasLimit,\n    uint32 stalenessSeconds,\n    uint32 gasAfterPaymentCalculation,\n    int256 fallbackWeiPerUnitLink,\n    FeeConfig feeConfig\n  );\n\n  constructor(\n    address link,\n    address blockhashStore,\n    address linkEthFeed\n  ) ConfirmedOwner(msg.sender) {\n    LINK = LinkTokenInterface(link);\n    LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\n    BLOCKHASH_STORE = BlockhashStoreInterface(blockhashStore);\n  }\n\n  /**\n   * @notice Registers a proving key to an oracle.\n   * @param oracle address of the oracle\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n   */\n  function registerProvingKey(address oracle, uint256[2] calldata publicProvingKey) external onlyOwner {\n    bytes32 kh = hashOfKey(publicProvingKey);\n    if (s_provingKeys[kh] != address(0)) {\n      revert ProvingKeyAlreadyRegistered(kh);\n    }\n    s_provingKeys[kh] = oracle;\n    s_provingKeyHashes.push(kh);\n    emit ProvingKeyRegistered(kh, oracle);\n  }\n\n  /**\n   * @notice Deregisters a proving key to an oracle.\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n   */\n  function deregisterProvingKey(uint256[2] calldata publicProvingKey) external onlyOwner {\n    bytes32 kh = hashOfKey(publicProvingKey);\n    address oracle = s_provingKeys[kh];\n    if (oracle == address(0)) {\n      revert NoSuchProvingKey(kh);\n    }\n    delete s_provingKeys[kh];\n    for (uint256 i = 0; i < s_provingKeyHashes.length; i++) {\n      if (s_provingKeyHashes[i] == kh) {\n        bytes32 last = s_provingKeyHashes[s_provingKeyHashes.length - 1];\n        // Copy last element and overwrite kh to be deleted with it\n        s_provingKeyHashes[i] = last;\n        s_provingKeyHashes.pop();\n      }\n    }\n    emit ProvingKeyDeregistered(kh, oracle);\n  }\n\n  /**\n   * @notice Returns the proving key hash key associated with this public key\n   * @param publicKey the key to return the hash of\n   */\n  function hashOfKey(uint256[2] memory publicKey) public pure returns (bytes32) {\n    return keccak256(abi.encode(publicKey));\n  }\n\n  /**\n   * @notice Sets the configuration of the vrfv2 coordinator\n   * @param minimumRequestConfirmations global min for request confirmations\n   * @param maxGasLimit global max for request gas limit\n   * @param stalenessSeconds if the eth/link feed is more stale then this, use the fallback price\n   * @param gasAfterPaymentCalculation gas used in doing accounting after completing the gas measurement\n   * @param fallbackWeiPerUnitLink fallback eth/link price in the case of a stale feed\n   * @param feeConfig fee tier configuration\n   */\n  function setConfig(\n    uint16 minimumRequestConfirmations,\n    uint32 maxGasLimit,\n    uint32 stalenessSeconds,\n    uint32 gasAfterPaymentCalculation,\n    int256 fallbackWeiPerUnitLink,\n    FeeConfig memory feeConfig\n  ) external onlyOwner {\n    if (minimumRequestConfirmations > MAX_REQUEST_CONFIRMATIONS) {\n      revert InvalidRequestConfirmations(\n        minimumRequestConfirmations,\n        minimumRequestConfirmations,\n        MAX_REQUEST_CONFIRMATIONS\n      );\n    }\n    if (fallbackWeiPerUnitLink <= 0) {\n      revert InvalidLinkWeiPrice(fallbackWeiPerUnitLink);\n    }\n    s_config = Config({\n      minimumRequestConfirmations: minimumRequestConfirmations,\n      maxGasLimit: maxGasLimit,\n      stalenessSeconds: stalenessSeconds,\n      gasAfterPaymentCalculation: gasAfterPaymentCalculation,\n      reentrancyLock: false\n    });\n    s_feeConfig = feeConfig;\n    s_fallbackWeiPerUnitLink = fallbackWeiPerUnitLink;\n    emit ConfigSet(\n      minimumRequestConfirmations,\n      maxGasLimit,\n      stalenessSeconds,\n      gasAfterPaymentCalculation,\n      fallbackWeiPerUnitLink,\n      s_feeConfig\n    );\n  }\n\n  function getConfig()\n    external\n    view\n    returns (\n      uint16 minimumRequestConfirmations,\n      uint32 maxGasLimit,\n      uint32 stalenessSeconds,\n      uint32 gasAfterPaymentCalculation\n    )\n  {\n    return (\n      s_config.minimumRequestConfirmations,\n      s_config.maxGasLimit,\n      s_config.stalenessSeconds,\n      s_config.gasAfterPaymentCalculation\n    );\n  }\n\n  function getFeeConfig()\n    external\n    view\n    returns (\n      uint32 fulfillmentFlatFeeLinkPPMTier1,\n      uint32 fulfillmentFlatFeeLinkPPMTier2,\n      uint32 fulfillmentFlatFeeLinkPPMTier3,\n      uint32 fulfillmentFlatFeeLinkPPMTier4,\n      uint32 fulfillmentFlatFeeLinkPPMTier5,\n      uint24 reqsForTier2,\n      uint24 reqsForTier3,\n      uint24 reqsForTier4,\n      uint24 reqsForTier5\n    )\n  {\n    return (\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier1,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier2,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier3,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier4,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier5,\n      s_feeConfig.reqsForTier2,\n      s_feeConfig.reqsForTier3,\n      s_feeConfig.reqsForTier4,\n      s_feeConfig.reqsForTier5\n    );\n  }\n\n  function getTotalBalance() external view returns (uint256) {\n    return s_totalBalance;\n  }\n\n  function getFallbackWeiPerUnitLink() external view returns (int256) {\n    return s_fallbackWeiPerUnitLink;\n  }\n\n  /**\n   * @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\n   * @param subId subscription id\n   * @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\n   */\n  function ownerCancelSubscription(uint64 subId) external onlyOwner {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    cancelSubscriptionHelper(subId, s_subscriptionConfigs[subId].owner);\n  }\n\n  /**\n   * @notice Recover link sent with transfer instead of transferAndCall.\n   * @param to address to send link to\n   */\n  function recoverFunds(address to) external onlyOwner {\n    uint256 externalBalance = LINK.balanceOf(address(this));\n    uint256 internalBalance = uint256(s_totalBalance);\n    if (internalBalance > externalBalance) {\n      revert BalanceInvariantViolated(internalBalance, externalBalance);\n    }\n    if (internalBalance < externalBalance) {\n      uint256 amount = externalBalance - internalBalance;\n      LINK.transfer(to, amount);\n      emit FundsRecovered(to, amount);\n    }\n    // If the balances are equal, nothing to be done.\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function getRequestConfig()\n    external\n    view\n    override\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    )\n  {\n    return (s_config.minimumRequestConfirmations, s_config.maxGasLimit, s_provingKeyHashes);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 requestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external override nonReentrant returns (uint256) {\n    // Input validation using the subscription storage.\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    // Its important to ensure that the consumer is in fact who they say they\n    // are, otherwise they could use someone else's subscription balance.\n    // A nonce of 0 indicates consumer is not allocated to the sub.\n    uint64 currentNonce = s_consumers[msg.sender][subId];\n    if (currentNonce == 0) {\n      revert InvalidConsumer(subId, msg.sender);\n    }\n    // Input validation using the config storage word.\n    if (\n      requestConfirmations < s_config.minimumRequestConfirmations || requestConfirmations > MAX_REQUEST_CONFIRMATIONS\n    ) {\n      revert InvalidRequestConfirmations(\n        requestConfirmations,\n        s_config.minimumRequestConfirmations,\n        MAX_REQUEST_CONFIRMATIONS\n      );\n    }\n    // No lower bound on the requested gas limit. A user could request 0\n    // and they would simply be billed for the proof verification and wouldn't be\n    // able to do anything with the random value.\n    if (callbackGasLimit > s_config.maxGasLimit) {\n      revert GasLimitTooBig(callbackGasLimit, s_config.maxGasLimit);\n    }\n    if (numWords > MAX_NUM_WORDS) {\n      revert NumWordsTooBig(numWords, MAX_NUM_WORDS);\n    }\n    // Note we do not check whether the keyHash is valid to save gas.\n    // The consequence for users is that they can send requests\n    // for invalid keyHashes which will simply not be fulfilled.\n    uint64 nonce = currentNonce + 1;\n    (uint256 requestId, uint256 preSeed) = computeRequestId(keyHash, msg.sender, subId, nonce);\n\n    s_requestCommitments[requestId] = keccak256(\n      abi.encode(requestId, block.number, subId, callbackGasLimit, numWords, msg.sender)\n    );\n    emit RandomWordsRequested(\n      keyHash,\n      requestId,\n      preSeed,\n      subId,\n      requestConfirmations,\n      callbackGasLimit,\n      numWords,\n      msg.sender\n    );\n    s_consumers[msg.sender][subId] = nonce;\n\n    return requestId;\n  }\n\n  /**\n   * @notice Get request commitment\n   * @param requestId id of request\n   * @dev used to determine if a request is fulfilled or not\n   */\n  function getCommitment(uint256 requestId) external view returns (bytes32) {\n    return s_requestCommitments[requestId];\n  }\n\n  function computeRequestId(\n    bytes32 keyHash,\n    address sender,\n    uint64 subId,\n    uint64 nonce\n  ) private pure returns (uint256, uint256) {\n    uint256 preSeed = uint256(keccak256(abi.encode(keyHash, sender, subId, nonce)));\n    return (uint256(keccak256(abi.encode(keyHash, preSeed))), preSeed);\n  }\n\n  /**\n   * @dev calls target address with exactly gasAmount gas and data as calldata\n   * or reverts if at least gasAmount gas is not available.\n   */\n  function callWithExactGas(\n    uint256 gasAmount,\n    address target,\n    bytes memory data\n  ) private returns (bool success) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let g := gas()\n      // Compute g -= GAS_FOR_CALL_EXACT_CHECK and check for underflow\n      // The gas actually passed to the callee is min(gasAmount, 63//64*gas available).\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\n      // as we do not want to provide them with less, however that check itself costs\n      // gas.  GAS_FOR_CALL_EXACT_CHECK ensures we have at least enough gas to be able\n      // to revert if gasAmount >  63//64*gas available.\n      if lt(g, GAS_FOR_CALL_EXACT_CHECK) {\n        revert(0, 0)\n      }\n      g := sub(g, GAS_FOR_CALL_EXACT_CHECK)\n      // if g - g//64 <= gasAmount, revert\n      // (we subtract g//64 because of EIP-150)\n      if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\n        revert(0, 0)\n      }\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      if iszero(extcodesize(target)) {\n        revert(0, 0)\n      }\n      // call and return whether we succeeded. ignore return data\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\n      success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\n    }\n    return success;\n  }\n\n  function getRandomnessFromProof(Proof memory proof, RequestCommitment memory rc)\n    private\n    view\n    returns (\n      bytes32 keyHash,\n      uint256 requestId,\n      uint256 randomness\n    )\n  {\n    keyHash = hashOfKey(proof.pk);\n    // Only registered proving keys are permitted.\n    address oracle = s_provingKeys[keyHash];\n    if (oracle == address(0)) {\n      revert NoSuchProvingKey(keyHash);\n    }\n    requestId = uint256(keccak256(abi.encode(keyHash, proof.seed)));\n    bytes32 commitment = s_requestCommitments[requestId];\n    if (commitment == 0) {\n      revert NoCorrespondingRequest();\n    }\n    if (\n      commitment != keccak256(abi.encode(requestId, rc.blockNum, rc.subId, rc.callbackGasLimit, rc.numWords, rc.sender))\n    ) {\n      revert IncorrectCommitment();\n    }\n\n    bytes32 blockHash = blockhash(rc.blockNum);\n    if (blockHash == bytes32(0)) {\n      blockHash = BLOCKHASH_STORE.getBlockhash(rc.blockNum);\n      if (blockHash == bytes32(0)) {\n        revert BlockhashNotInStore(rc.blockNum);\n      }\n    }\n\n    // The seed actually used by the VRF machinery, mixing in the blockhash\n    uint256 actualSeed = uint256(keccak256(abi.encodePacked(proof.seed, blockHash)));\n    randomness = VRF.randomValueFromVRFProof(proof, actualSeed); // Reverts on failure\n  }\n\n  /*\n   * @notice Compute fee based on the request count\n   * @param reqCount number of requests\n   * @return feePPM fee in LINK PPM\n   */\n  function getFeeTier(uint64 reqCount) public view returns (uint32) {\n    FeeConfig memory fc = s_feeConfig;\n    if (0 <= reqCount && reqCount <= fc.reqsForTier2) {\n      return fc.fulfillmentFlatFeeLinkPPMTier1;\n    }\n    if (fc.reqsForTier2 < reqCount && reqCount <= fc.reqsForTier3) {\n      return fc.fulfillmentFlatFeeLinkPPMTier2;\n    }\n    if (fc.reqsForTier3 < reqCount && reqCount <= fc.reqsForTier4) {\n      return fc.fulfillmentFlatFeeLinkPPMTier3;\n    }\n    if (fc.reqsForTier4 < reqCount && reqCount <= fc.reqsForTier5) {\n      return fc.fulfillmentFlatFeeLinkPPMTier4;\n    }\n    return fc.fulfillmentFlatFeeLinkPPMTier5;\n  }\n\n  /*\n   * @notice Fulfill a randomness request\n   * @param proof contains the proof and randomness\n   * @param rc request commitment pre-image, committed to at request time\n   * @return payment amount billed to the subscription\n   * @dev simulated offchain to determine if sufficient balance is present to fulfill the request\n   */\n  function fulfillRandomWords(Proof memory proof, RequestCommitment memory rc) external nonReentrant returns (uint96) {\n    uint256 startGas = gasleft();\n    (bytes32 keyHash, uint256 requestId, uint256 randomness) = getRandomnessFromProof(proof, rc);\n\n    uint256[] memory randomWords = new uint256[](rc.numWords);\n    for (uint256 i = 0; i < rc.numWords; i++) {\n      randomWords[i] = uint256(keccak256(abi.encode(randomness, i)));\n    }\n\n    delete s_requestCommitments[requestId];\n    VRFConsumerBaseV2 v;\n    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, requestId, randomWords);\n    // Call with explicitly the amount of callback gas requested\n    // Important to not let them exhaust the gas budget and avoid oracle payment.\n    // Do not allow any non-view/non-pure coordinator functions to be called\n    // during the consumers callback code via reentrancyLock.\n    // Note that callWithExactGas will revert if we do not have sufficient gas\n    // to give the callee their requested amount.\n    s_config.reentrancyLock = true;\n    bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\n    s_config.reentrancyLock = false;\n\n    // Increment the req count for fee tier selection.\n    uint64 reqCount = s_subscriptions[rc.subId].reqCount;\n    s_subscriptions[rc.subId].reqCount += 1;\n\n    // We want to charge users exactly for how much gas they use in their callback.\n    // The gasAfterPaymentCalculation is meant to cover these additional operations where we\n    // decrement the subscription balance and increment the oracles withdrawable balance.\n    // We also add the flat link fee to the payment amount.\n    // Its specified in millionths of link, if s_config.fulfillmentFlatFeeLinkPPM = 1\n    // 1 link / 1e6 = 1e18 juels / 1e6 = 1e12 juels.\n    uint96 payment = calculatePaymentAmount(\n      startGas,\n      s_config.gasAfterPaymentCalculation,\n      getFeeTier(reqCount),\n      tx.gasprice\n    );\n    if (s_subscriptions[rc.subId].balance < payment) {\n      revert InsufficientBalance();\n    }\n    s_subscriptions[rc.subId].balance -= payment;\n    s_withdrawableTokens[s_provingKeys[keyHash]] += payment;\n    // Include payment in the event for tracking costs.\n    emit RandomWordsFulfilled(requestId, randomness, payment, success);\n    return payment;\n  }\n\n  // Get the amount of gas used for fulfillment\n  function calculatePaymentAmount(\n    uint256 startGas,\n    uint256 gasAfterPaymentCalculation,\n    uint32 fulfillmentFlatFeeLinkPPM,\n    uint256 weiPerUnitGas\n  ) internal view returns (uint96) {\n    int256 weiPerUnitLink;\n    weiPerUnitLink = getFeedData();\n    if (weiPerUnitLink <= 0) {\n      revert InvalidLinkWeiPrice(weiPerUnitLink);\n    }\n    // (1e18 juels/link) (wei/gas * gas) / (wei/link) = juels\n    uint256 paymentNoFee = (1e18 * weiPerUnitGas * (gasAfterPaymentCalculation + startGas - gasleft())) /\n      uint256(weiPerUnitLink);\n    uint256 fee = 1e12 * uint256(fulfillmentFlatFeeLinkPPM);\n    if (paymentNoFee > (1e27 - fee)) {\n      revert PaymentTooLarge(); // Payment + fee cannot be more than all of the link in existence.\n    }\n    return uint96(paymentNoFee + fee);\n  }\n\n  function getFeedData() private view returns (int256) {\n    uint32 stalenessSeconds = s_config.stalenessSeconds;\n    bool staleFallback = stalenessSeconds > 0;\n    uint256 timestamp;\n    int256 weiPerUnitLink;\n    (, weiPerUnitLink, , timestamp, ) = LINK_ETH_FEED.latestRoundData();\n    // solhint-disable-next-line not-rely-on-time\n    if (staleFallback && stalenessSeconds < block.timestamp - timestamp) {\n      weiPerUnitLink = s_fallbackWeiPerUnitLink;\n    }\n    return weiPerUnitLink;\n  }\n\n  /*\n   * @notice Oracle withdraw LINK earned through fulfilling requests\n   * @param recipient where to send the funds\n   * @param amount amount to withdraw\n   */\n  function oracleWithdraw(address recipient, uint96 amount) external nonReentrant {\n    if (s_withdrawableTokens[msg.sender] < amount) {\n      revert InsufficientBalance();\n    }\n    s_withdrawableTokens[msg.sender] -= amount;\n    s_totalBalance -= amount;\n    if (!LINK.transfer(recipient, amount)) {\n      revert InsufficientBalance();\n    }\n  }\n\n  function onTokenTransfer(\n    address, /* sender */\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant {\n    if (msg.sender != address(LINK)) {\n      revert OnlyCallableFromLink();\n    }\n    if (data.length != 32) {\n      revert InvalidCalldata();\n    }\n    uint64 subId = abi.decode(data, (uint64));\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    // We do not check that the msg.sender is the subscription owner,\n    // anyone can fund a subscription.\n    uint256 oldBalance = s_subscriptions[subId].balance;\n    s_subscriptions[subId].balance += uint96(amount);\n    s_totalBalance += uint96(amount);\n    emit SubscriptionFunded(subId, oldBalance, oldBalance + amount);\n  }\n\n  function getCurrentSubId() external view returns (uint64) {\n    return s_currentSubId;\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    override\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    )\n  {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    return (\n      s_subscriptions[subId].balance,\n      s_subscriptions[subId].reqCount,\n      s_subscriptionConfigs[subId].owner,\n      s_subscriptionConfigs[subId].consumers\n    );\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function createSubscription() external override nonReentrant returns (uint64) {\n    s_currentSubId++;\n    uint64 currentSubId = s_currentSubId;\n    address[] memory consumers = new address[](0);\n    s_subscriptions[currentSubId] = Subscription({balance: 0, reqCount: 0});\n    s_subscriptionConfigs[currentSubId] = SubscriptionConfig({\n      owner: msg.sender,\n      requestedOwner: address(0),\n      consumers: consumers\n    });\n\n    emit SubscriptionCreated(currentSubId, msg.sender);\n    return currentSubId;\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)\n    external\n    override\n    onlySubOwner(subId)\n    nonReentrant\n  {\n    // Proposing to address(0) would never be claimable so don't need to check.\n    if (s_subscriptionConfigs[subId].requestedOwner != newOwner) {\n      s_subscriptionConfigs[subId].requestedOwner = newOwner;\n      emit SubscriptionOwnerTransferRequested(subId, msg.sender, newOwner);\n    }\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external override nonReentrant {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (s_subscriptionConfigs[subId].requestedOwner != msg.sender) {\n      revert MustBeRequestedOwner(s_subscriptionConfigs[subId].requestedOwner);\n    }\n    address oldOwner = s_subscriptionConfigs[subId].owner;\n    s_subscriptionConfigs[subId].owner = msg.sender;\n    s_subscriptionConfigs[subId].requestedOwner = address(0);\n    emit SubscriptionOwnerTransferred(subId, oldOwner, msg.sender);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function removeConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n    if (s_consumers[consumer][subId] == 0) {\n      revert InvalidConsumer(subId, consumer);\n    }\n    // Note bounded by MAX_CONSUMERS\n    address[] memory consumers = s_subscriptionConfigs[subId].consumers;\n    uint256 lastConsumerIndex = consumers.length - 1;\n    for (uint256 i = 0; i < consumers.length; i++) {\n      if (consumers[i] == consumer) {\n        address last = consumers[lastConsumerIndex];\n        // Storage write to preserve last element\n        s_subscriptionConfigs[subId].consumers[i] = last;\n        // Storage remove last element\n        s_subscriptionConfigs[subId].consumers.pop();\n        break;\n      }\n    }\n    delete s_consumers[consumer][subId];\n    emit SubscriptionConsumerRemoved(subId, consumer);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function addConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n    // Already maxed, cannot add any more consumers.\n    if (s_subscriptionConfigs[subId].consumers.length == MAX_CONSUMERS) {\n      revert TooManyConsumers();\n    }\n    if (s_consumers[consumer][subId] != 0) {\n      // Idempotence - do nothing if already added.\n      // Ensures uniqueness in s_subscriptions[subId].consumers.\n      return;\n    }\n    // Initialize the nonce to 1, indicating the consumer is allocated.\n    s_consumers[consumer][subId] = 1;\n    s_subscriptionConfigs[subId].consumers.push(consumer);\n\n    emit SubscriptionConsumerAdded(subId, consumer);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function cancelSubscription(uint64 subId, address to) external override onlySubOwner(subId) nonReentrant {\n    if (pendingRequestExists(subId)) {\n      revert PendingRequestExists();\n    }\n    cancelSubscriptionHelper(subId, to);\n  }\n\n  function cancelSubscriptionHelper(uint64 subId, address to) private nonReentrant {\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\n    Subscription memory sub = s_subscriptions[subId];\n    uint96 balance = sub.balance;\n    // Note bounded by MAX_CONSUMERS;\n    // If no consumers, does nothing.\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\n      delete s_consumers[subConfig.consumers[i]][subId];\n    }\n    delete s_subscriptionConfigs[subId];\n    delete s_subscriptions[subId];\n    s_totalBalance -= balance;\n    if (!LINK.transfer(to, uint256(balance))) {\n      revert InsufficientBalance();\n    }\n    emit SubscriptionCanceled(subId, to, balance);\n  }\n\n  /*\n   * @noticeCheck to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId where to send the funds\n   * @return exits true if outstanding requests\n   * @dev Looping is bounded to MAX_CONSUMERS*(number of keyhashes).\n   * @dev Used to disable subscription canceling while outstanding request are present.\n   */\n  function pendingRequestExists(uint64 subId) public view returns (bool) {\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\n      for (uint256 j = 0; j < s_provingKeyHashes.length; j++) {\n        (uint256 reqId, ) = computeRequestId(\n          s_provingKeyHashes[j],\n          subConfig.consumers[i],\n          subId,\n          s_consumers[subConfig.consumers[i]][subId]\n        );\n        if (s_requestCommitments[reqId] != 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  modifier onlySubOwner(uint64 subId) {\n    address owner = s_subscriptionConfigs[subId].owner;\n    if (owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (msg.sender != owner) {\n      revert MustBeSubOwner(owner);\n    }\n    _;\n  }\n\n  modifier nonReentrant() {\n    if (s_config.reentrancyLock) {\n      revert Reentrant();\n    }\n    _;\n  }\n\n  /**\n   * @notice The type and version of this contract\n   * @return Type and version string\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"VRFCoordinatorV2 1.0.0\";\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/BlockhashStoreInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface BlockhashStoreInterface {\n  function getBlockhash(uint256 number) external view returns (bytes32);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract TypeAndVersionInterface {\n  function typeAndVersion() external pure virtual returns (string memory);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ERC677ReceiverInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface ERC677ReceiverInterface {\n  function onTokenTransfer(\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/dev/VRF.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/** ****************************************************************************\n  * @notice Verification of verifiable-random-function (VRF) proofs, following\n  * @notice https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\n  * @notice See https://eprint.iacr.org/2017/099.pdf for security proofs.\n\n  * @dev Bibliographic references:\n\n  * @dev Goldberg, et al., \"Verifiable Random Functions (VRFs)\", Internet Draft\n  * @dev draft-irtf-cfrg-vrf-05, IETF, Aug 11 2019,\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05\n\n  * @dev Papadopoulos, et al., \"Making NSEC5 Practical for DNSSEC\", Cryptology\n  * @dev ePrint Archive, Report 2017/099, https://eprint.iacr.org/2017/099.pdf\n  * ****************************************************************************\n  * @dev USAGE\n\n  * @dev The main entry point is randomValueFromVRFProof. See its docstring.\n  * ****************************************************************************\n  * @dev PURPOSE\n\n  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n  * @dev to Vera the verifier in such a way that Vera can be sure he's not\n  * @dev making his output up to suit himself. Reggie provides Vera a public key\n  * @dev to which he knows the secret key. Each time Vera provides a seed to\n  * @dev Reggie, he gives back a value which is computed completely\n  * @dev deterministically from the seed and the secret key.\n\n  * @dev Reggie provides a proof by which Vera can verify that the output was\n  * @dev correctly computed once Reggie tells it to her, but without that proof,\n  * @dev the output is computationally indistinguishable to her from a uniform\n  * @dev random sample from the output space.\n\n  * @dev The purpose of this contract is to perform that verification.\n  * ****************************************************************************\n  * @dev DESIGN NOTES\n\n  * @dev The VRF algorithm verified here satisfies the full uniqueness, full\n  * @dev collision resistance, and full pseudo-randomness security properties.\n  * @dev See \"SECURITY PROPERTIES\" below, and\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-3\n\n  * @dev An elliptic curve point is generally represented in the solidity code\n  * @dev as a uint256[2], corresponding to its affine coordinates in\n  * @dev GF(FIELD_SIZE).\n\n  * @dev For the sake of efficiency, this implementation deviates from the spec\n  * @dev in some minor ways:\n\n  * @dev - Keccak hash rather than the SHA256 hash recommended in\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\n  * @dev   Keccak costs much less gas on the EVM, and provides similar security.\n\n  * @dev - Secp256k1 curve instead of the P-256 or ED25519 curves recommended in\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\n  * @dev   For curve-point multiplication, it's much cheaper to abuse ECRECOVER\n\n  * @dev - hashToCurve recursively hashes until it finds a curve x-ordinate. On\n  * @dev   the EVM, this is slightly more efficient than the recommendation in\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\n  * @dev   step 5, to concatenate with a nonce then hash, and rehash with the\n  * @dev   nonce updated until a valid x-ordinate is found.\n\n  * @dev - hashToCurve does not include a cipher version string or the byte 0x1\n  * @dev   in the hash message, as recommended in step 5.B of the draft\n  * @dev   standard. They are unnecessary here because no variation in the\n  * @dev   cipher suite is allowed.\n\n  * @dev - Similarly, the hash input in scalarFromCurvePoints does not include a\n  * @dev   commitment to the cipher suite, either, which differs from step 2 of\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\n  * @dev   . Also, the hash input is the concatenation of the uncompressed\n  * @dev   points, not the compressed points as recommended in step 3.\n\n  * @dev - In the calculation of the challenge value \"c\", the \"u\" value (i.e.\n  * @dev   the value computed by Reggie as the nonce times the secp256k1\n  * @dev   generator point, see steps 5 and 7 of\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\n  * @dev   ) is replaced by its ethereum address, i.e. the lower 160 bits of the\n  * @dev   keccak hash of the original u. This is because we only verify the\n  * @dev   calculation of u up to its address, by abusing ECRECOVER.\n  * ****************************************************************************\n  * @dev   SECURITY PROPERTIES\n\n  * @dev Here are the security properties for this VRF:\n\n  * @dev Full uniqueness: For any seed and valid VRF public key, there is\n  * @dev   exactly one VRF output which can be proved to come from that seed, in\n  * @dev   the sense that the proof will pass verifyVRFProof.\n\n  * @dev Full collision resistance: It's cryptographically infeasible to find\n  * @dev   two seeds with same VRF output from a fixed, valid VRF key\n\n  * @dev Full pseudorandomness: Absent the proofs that the VRF outputs are\n  * @dev   derived from a given seed, the outputs are computationally\n  * @dev   indistinguishable from randomness.\n\n  * @dev https://eprint.iacr.org/2017/099.pdf, Appendix B contains the proofs\n  * @dev for these properties.\n\n  * @dev For secp256k1, the key validation described in section\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.6\n  * @dev is unnecessary, because secp256k1 has cofactor 1, and the\n  * @dev representation of the public key used here (affine x- and y-ordinates\n  * @dev of the secp256k1 point on the standard y^2=x^3+7 curve) cannot refer to\n  * @dev the point at infinity.\n  * ****************************************************************************\n  * @dev OTHER SECURITY CONSIDERATIONS\n  *\n  * @dev The seed input to the VRF could in principle force an arbitrary amount\n  * @dev of work in hashToCurve, by requiring extra rounds of hashing and\n  * @dev checking whether that's yielded the x ordinate of a secp256k1 point.\n  * @dev However, under the Random Oracle Model the probability of choosing a\n  * @dev point which forces n extra rounds in hashToCurve is 2. The base cost\n  * @dev for calling hashToCurve is about 25,000 gas, and each round of checking\n  * @dev for a valid x ordinate costs about 15,555 gas, so to find a seed for\n  * @dev which hashToCurve would cost more than 2,017,000 gas, one would have to\n  * @dev try, in expectation, about 2 seeds, which is infeasible for any\n  * @dev foreseeable computational resources. (25,000 + 128 * 15,555 < 2,017,000.)\n\n  * @dev Since the gas block limit for the Ethereum main net is 10,000,000 gas,\n  * @dev this means it is infeasible for an adversary to prevent correct\n  * @dev operation of this contract by choosing an adverse seed.\n\n  * @dev (See TestMeasureHashToCurveGasCost for verification of the gas cost for\n  * @dev hashToCurve.)\n\n  * @dev It may be possible to make a secure constant-time hashToCurve function.\n  * @dev See notes in hashToCurve docstring.\n*/\ncontract VRF {\n  // See https://www.secg.org/sec2-v2.pdf, section 2.4.1, for these constants.\n  // Number of points in Secp256k1\n  uint256 private constant GROUP_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n  // Prime characteristic of the galois field over which Secp256k1 is defined\n  uint256 private constant FIELD_SIZE =\n    // solium-disable-next-line indentation\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n  uint256 private constant WORD_LENGTH_BYTES = 0x20;\n\n  // (base^exponent) % FIELD_SIZE\n  // Cribbed from https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4\n  function bigModExp(uint256 base, uint256 exponent) internal view returns (uint256 exponentiation) {\n    uint256 callResult;\n    uint256[6] memory bigModExpContractInputs;\n    bigModExpContractInputs[0] = WORD_LENGTH_BYTES; // Length of base\n    bigModExpContractInputs[1] = WORD_LENGTH_BYTES; // Length of exponent\n    bigModExpContractInputs[2] = WORD_LENGTH_BYTES; // Length of modulus\n    bigModExpContractInputs[3] = base;\n    bigModExpContractInputs[4] = exponent;\n    bigModExpContractInputs[5] = FIELD_SIZE;\n    uint256[1] memory output;\n    assembly {\n      // solhint-disable-line no-inline-assembly\n      callResult := staticcall(\n        not(0), // Gas cost: no limit\n        0x05, // Bigmodexp contract address\n        bigModExpContractInputs,\n        0xc0, // Length of input segment: 6*0x20-bytes\n        output,\n        0x20 // Length of output segment\n      )\n    }\n    if (callResult == 0) {\n      revert(\"bigModExp failure!\");\n    }\n    return output[0];\n  }\n\n  // Let q=FIELD_SIZE. q % 4 = 3,  xr^2 mod q  x^SQRT_POWERr mod q.  See\n  // https://en.wikipedia.org/wiki/Modular_square_root#Prime_or_prime_power_modulus\n  uint256 private constant SQRT_POWER = (FIELD_SIZE + 1) >> 2;\n\n  // Computes a s.t. a^2 = x in the field. Assumes a exists\n  function squareRoot(uint256 x) internal view returns (uint256) {\n    return bigModExp(x, SQRT_POWER);\n  }\n\n  // The value of y^2 given that (x,y) is on secp256k1.\n  function ySquared(uint256 x) internal pure returns (uint256) {\n    // Curve is y^2=x^3+7. See section 2.4.1 of https://www.secg.org/sec2-v2.pdf\n    uint256 xCubed = mulmod(x, mulmod(x, x, FIELD_SIZE), FIELD_SIZE);\n    return addmod(xCubed, 7, FIELD_SIZE);\n  }\n\n  // True iff p is on secp256k1\n  function isOnCurve(uint256[2] memory p) internal pure returns (bool) {\n    // Section 2.3.6. in https://www.secg.org/sec1-v2.pdf\n    // requires each ordinate to be in [0, ..., FIELD_SIZE-1]\n    require(p[0] < FIELD_SIZE, \"invalid x-ordinate\");\n    require(p[1] < FIELD_SIZE, \"invalid y-ordinate\");\n    return ySquared(p[0]) == mulmod(p[1], p[1], FIELD_SIZE);\n  }\n\n  // Hash x uniformly into {0, ..., FIELD_SIZE-1}.\n  function fieldHash(bytes memory b) internal pure returns (uint256 x_) {\n    x_ = uint256(keccak256(b));\n    // Rejecting if x >= FIELD_SIZE corresponds to step 2.1 in section 2.3.4 of\n    // http://www.secg.org/sec1-v2.pdf , which is part of the definition of\n    // string_to_point in the IETF draft\n    while (x_ >= FIELD_SIZE) {\n      x_ = uint256(keccak256(abi.encodePacked(x_)));\n    }\n  }\n\n  // Hash b to a random point which hopefully lies on secp256k1. The y ordinate\n  // is always even, due to\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\n  // step 5.C, which references arbitrary_string_to_point, defined in\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5 as\n  // returning the point with given x ordinate, and even y ordinate.\n  function newCandidateSecp256k1Point(bytes memory b) internal view returns (uint256[2] memory p) {\n    unchecked {\n      p[0] = fieldHash(b);\n      p[1] = squareRoot(ySquared(p[0]));\n      if (p[1] % 2 == 1) {\n        // Note that 0 <= p[1] < FIELD_SIZE\n        // so this cannot wrap, we use unchecked to save gas.\n        p[1] = FIELD_SIZE - p[1];\n      }\n    }\n  }\n\n  // Domain-separation tag for initial hash in hashToCurve. Corresponds to\n  // vrf.go/hashToCurveHashPrefix\n  uint256 internal constant HASH_TO_CURVE_HASH_PREFIX = 1;\n\n  // Cryptographic hash function onto the curve.\n  //\n  // Corresponds to algorithm in section 5.4.1.1 of the draft standard. (But see\n  // DESIGN NOTES above for slight differences.)\n  //\n  // TODO(alx): Implement a bounded-computation hash-to-curve, as described in\n  // \"Construction of Rational Points on Elliptic Curves over Finite Fields\"\n  // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.831.5299&rep=rep1&type=pdf\n  // and suggested by\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-01#section-5.2.2\n  // (Though we can't used exactly that because secp256k1's j-invariant is 0.)\n  //\n  // This would greatly simplify the analysis in \"OTHER SECURITY CONSIDERATIONS\"\n  // https://www.pivotaltracker.com/story/show/171120900\n  function hashToCurve(uint256[2] memory pk, uint256 input) internal view returns (uint256[2] memory rv) {\n    rv = newCandidateSecp256k1Point(abi.encodePacked(HASH_TO_CURVE_HASH_PREFIX, pk, input));\n    while (!isOnCurve(rv)) {\n      rv = newCandidateSecp256k1Point(abi.encodePacked(rv[0]));\n    }\n  }\n\n  /** *********************************************************************\n   * @notice Check that product==scalar*multiplicand\n   *\n   * @dev Based on Vitalik Buterin's idea in ethresear.ch post cited below.\n   *\n   * @param multiplicand: secp256k1 point\n   * @param scalar: non-zero GF(GROUP_ORDER) scalar\n   * @param product: secp256k1 expected to be multiplier * multiplicand\n   * @return verifies true iff product==scalar*multiplicand, with cryptographically high probability\n   */\n  function ecmulVerify(\n    uint256[2] memory multiplicand,\n    uint256 scalar,\n    uint256[2] memory product\n  ) internal pure returns (bool verifies) {\n    require(scalar != 0, \"zero scalar\"); // Rules out an ecrecover failure case\n    uint256 x = multiplicand[0]; // x ordinate of multiplicand\n    uint8 v = multiplicand[1] % 2 == 0 ? 27 : 28; // parity of y ordinate\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n    // Point corresponding to address ecrecover(0, v, x, s=scalar*x) is\n    // (x mod GROUP_ORDER) * (scalar * x * multiplicand - 0 * g), i.e.\n    // scalar*multiplicand. See https://crypto.stackexchange.com/a/18106\n    bytes32 scalarTimesX = bytes32(mulmod(scalar, x, GROUP_ORDER));\n    address actual = ecrecover(bytes32(0), v, bytes32(x), scalarTimesX);\n    // Explicit conversion to address takes bottom 160 bits\n    address expected = address(uint160(uint256(keccak256(abi.encodePacked(product)))));\n    return (actual == expected);\n  }\n\n  // Returns x1/z1-x2/z2=(x1z2-x2z1)/(z1z2) in projective coordinates on P()\n  function projectiveSub(\n    uint256 x1,\n    uint256 z1,\n    uint256 x2,\n    uint256 z2\n  ) internal pure returns (uint256 x3, uint256 z3) {\n    unchecked {\n      uint256 num1 = mulmod(z2, x1, FIELD_SIZE);\n      // Note this cannot wrap since x2 is a point in [0, FIELD_SIZE-1]\n      // we use unchecked to save gas.\n      uint256 num2 = mulmod(FIELD_SIZE - x2, z1, FIELD_SIZE);\n      (x3, z3) = (addmod(num1, num2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\n    }\n  }\n\n  // Returns x1/z1*x2/z2=(x1x2)/(z1z2), in projective coordinates on P()\n  function projectiveMul(\n    uint256 x1,\n    uint256 z1,\n    uint256 x2,\n    uint256 z2\n  ) internal pure returns (uint256 x3, uint256 z3) {\n    (x3, z3) = (mulmod(x1, x2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\n  }\n\n  /** **************************************************************************\n        @notice Computes elliptic-curve sum, in projective co-ordinates\n\n        @dev Using projective coordinates avoids costly divisions\n\n        @dev To use this with p and q in affine coordinates, call\n        @dev projectiveECAdd(px, py, qx, qy). This will return\n        @dev the addition of (px, py, 1) and (qx, qy, 1), in the\n        @dev secp256k1 group.\n\n        @dev This can be used to calculate the z which is the inverse to zInv\n        @dev in isValidVRFOutput. But consider using a faster\n        @dev re-implementation such as ProjectiveECAdd in the golang vrf package.\n\n        @dev This function assumes [px,py,1],[qx,qy,1] are valid projective\n             coordinates of secp256k1 points. That is safe in this contract,\n             because this method is only used by linearCombination, which checks\n             points are on the curve via ecrecover.\n        **************************************************************************\n        @param px The first affine coordinate of the first summand\n        @param py The second affine coordinate of the first summand\n        @param qx The first affine coordinate of the second summand\n        @param qy The second affine coordinate of the second summand\n\n        (px,py) and (qx,qy) must be distinct, valid secp256k1 points.\n        **************************************************************************\n        Return values are projective coordinates of [px,py,1]+[qx,qy,1] as points\n        on secp256k1, in P()\n        @return sx\n        @return sy\n        @return sz\n    */\n  function projectiveECAdd(\n    uint256 px,\n    uint256 py,\n    uint256 qx,\n    uint256 qy\n  )\n    internal\n    pure\n    returns (\n      uint256 sx,\n      uint256 sy,\n      uint256 sz\n    )\n  {\n    unchecked {\n      // See \"Group law for E/K : y^2 = x^3 + ax + b\", in section 3.1.2, p. 80,\n      // \"Guide to Elliptic Curve Cryptography\" by Hankerson, Menezes and Vanstone\n      // We take the equations there for (sx,sy), and homogenize them to\n      // projective coordinates. That way, no inverses are required, here, and we\n      // only need the one inverse in affineECAdd.\n\n      // We only need the \"point addition\" equations from Hankerson et al. Can\n      // skip the \"point doubling\" equations because p1 == p2 is cryptographically\n      // impossible, and required not to be the case in linearCombination.\n\n      // Add extra \"projective coordinate\" to the two points\n      (uint256 z1, uint256 z2) = (1, 1);\n\n      // (lx, lz) = (qy-py)/(qx-px), i.e., gradient of secant line.\n      // Cannot wrap since px and py are in [0, FIELD_SIZE-1]\n      uint256 lx = addmod(qy, FIELD_SIZE - py, FIELD_SIZE);\n      uint256 lz = addmod(qx, FIELD_SIZE - px, FIELD_SIZE);\n\n      uint256 dx; // Accumulates denominator from sx calculation\n      // sx=((qy-py)/(qx-px))^2-px-qx\n      (sx, dx) = projectiveMul(lx, lz, lx, lz); // ((qy-py)/(qx-px))^2\n      (sx, dx) = projectiveSub(sx, dx, px, z1); // ((qy-py)/(qx-px))^2-px\n      (sx, dx) = projectiveSub(sx, dx, qx, z2); // ((qy-py)/(qx-px))^2-px-qx\n\n      uint256 dy; // Accumulates denominator from sy calculation\n      // sy=((qy-py)/(qx-px))(px-sx)-py\n      (sy, dy) = projectiveSub(px, z1, sx, dx); // px-sx\n      (sy, dy) = projectiveMul(sy, dy, lx, lz); // ((qy-py)/(qx-px))(px-sx)\n      (sy, dy) = projectiveSub(sy, dy, py, z1); // ((qy-py)/(qx-px))(px-sx)-py\n\n      if (dx != dy) {\n        // Cross-multiply to put everything over a common denominator\n        sx = mulmod(sx, dy, FIELD_SIZE);\n        sy = mulmod(sy, dx, FIELD_SIZE);\n        sz = mulmod(dx, dy, FIELD_SIZE);\n      } else {\n        // Already over a common denominator, use that for z ordinate\n        sz = dx;\n      }\n    }\n  }\n\n  // p1+p2, as affine points on secp256k1.\n  //\n  // invZ must be the inverse of the z returned by projectiveECAdd(p1, p2).\n  // It is computed off-chain to save gas.\n  //\n  // p1 and p2 must be distinct, because projectiveECAdd doesn't handle\n  // point doubling.\n  function affineECAdd(\n    uint256[2] memory p1,\n    uint256[2] memory p2,\n    uint256 invZ\n  ) internal pure returns (uint256[2] memory) {\n    uint256 x;\n    uint256 y;\n    uint256 z;\n    (x, y, z) = projectiveECAdd(p1[0], p1[1], p2[0], p2[1]);\n    require(mulmod(z, invZ, FIELD_SIZE) == 1, \"invZ must be inverse of z\");\n    // Clear the z ordinate of the projective representation by dividing through\n    // by it, to obtain the affine representation\n    return [mulmod(x, invZ, FIELD_SIZE), mulmod(y, invZ, FIELD_SIZE)];\n  }\n\n  // True iff address(c*p+s*g) == lcWitness, where g is generator. (With\n  // cryptographically high probability.)\n  function verifyLinearCombinationWithGenerator(\n    uint256 c,\n    uint256[2] memory p,\n    uint256 s,\n    address lcWitness\n  ) internal pure returns (bool) {\n    // Rule out ecrecover failure modes which return address 0.\n    unchecked {\n      require(lcWitness != address(0), \"bad witness\");\n      uint8 v = (p[1] % 2 == 0) ? 27 : 28; // parity of y-ordinate of p\n      // Note this cannot wrap (X - Y % X), but we use unchecked to save\n      // gas.\n      bytes32 pseudoHash = bytes32(GROUP_ORDER - mulmod(p[0], s, GROUP_ORDER)); // -s*p[0]\n      bytes32 pseudoSignature = bytes32(mulmod(c, p[0], GROUP_ORDER)); // c*p[0]\n      // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n      // The point corresponding to the address returned by\n      // ecrecover(-s*p[0],v,p[0],c*p[0]) is\n      // (p[0] mod GROUP_ORDER)*(c*p[0]-(-s)*p[0]*g)=c*p+s*g.\n      // See https://crypto.stackexchange.com/a/18106\n      // https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v\n      address computed = ecrecover(pseudoHash, v, bytes32(p[0]), pseudoSignature);\n      return computed == lcWitness;\n    }\n  }\n\n  // c*p1 + s*p2. Requires cp1Witness=c*p1 and sp2Witness=s*p2. Also\n  // requires cp1Witness != sp2Witness (which is fine for this application,\n  // since it is cryptographically impossible for them to be equal. In the\n  // (cryptographically impossible) case that a prover accidentally derives\n  // a proof with equal c*p1 and s*p2, they should retry with a different\n  // proof nonce.) Assumes that all points are on secp256k1\n  // (which is checked in verifyVRFProof below.)\n  function linearCombination(\n    uint256 c,\n    uint256[2] memory p1,\n    uint256[2] memory cp1Witness,\n    uint256 s,\n    uint256[2] memory p2,\n    uint256[2] memory sp2Witness,\n    uint256 zInv\n  ) internal pure returns (uint256[2] memory) {\n    unchecked {\n      // Note we are relying on the wrap around here\n      require((cp1Witness[0] % FIELD_SIZE) != (sp2Witness[0] % FIELD_SIZE), \"points in sum must be distinct\");\n      require(ecmulVerify(p1, c, cp1Witness), \"First mul check failed\");\n      require(ecmulVerify(p2, s, sp2Witness), \"Second mul check failed\");\n      return affineECAdd(cp1Witness, sp2Witness, zInv);\n    }\n  }\n\n  // Domain-separation tag for the hash taken in scalarFromCurvePoints.\n  // Corresponds to scalarFromCurveHashPrefix in vrf.go\n  uint256 internal constant SCALAR_FROM_CURVE_POINTS_HASH_PREFIX = 2;\n\n  // Pseudo-random number from inputs. Matches vrf.go/scalarFromCurvePoints, and\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\n  // The draft calls (in step 7, via the definition of string_to_int, in\n  // https://datatracker.ietf.org/doc/html/rfc8017#section-4.2 ) for taking the\n  // first hash without checking that it corresponds to a number less than the\n  // group order, which will lead to a slight bias in the sample.\n  //\n  // TODO(alx): We could save a bit of gas by following the standard here and\n  // using the compressed representation of the points, if we collated the y\n  // parities into a single bytes32.\n  // https://www.pivotaltracker.com/story/show/171120588\n  function scalarFromCurvePoints(\n    uint256[2] memory hash,\n    uint256[2] memory pk,\n    uint256[2] memory gamma,\n    address uWitness,\n    uint256[2] memory v\n  ) internal pure returns (uint256 s) {\n    return uint256(keccak256(abi.encodePacked(SCALAR_FROM_CURVE_POINTS_HASH_PREFIX, hash, pk, gamma, v, uWitness)));\n  }\n\n  // True if (gamma, c, s) is a correctly constructed randomness proof from pk\n  // and seed. zInv must be the inverse of the third ordinate from\n  // projectiveECAdd applied to cGammaWitness and sHashWitness. Corresponds to\n  // section 5.3 of the IETF draft.\n  //\n  // TODO(alx): Since I'm only using pk in the ecrecover call, I could only pass\n  // the x ordinate, and the parity of the y ordinate in the top bit of uWitness\n  // (which I could make a uint256 without using any extra space.) Would save\n  // about 2000 gas. https://www.pivotaltracker.com/story/show/170828567\n  function verifyVRFProof(\n    uint256[2] memory pk,\n    uint256[2] memory gamma,\n    uint256 c,\n    uint256 s,\n    uint256 seed,\n    address uWitness,\n    uint256[2] memory cGammaWitness,\n    uint256[2] memory sHashWitness,\n    uint256 zInv\n  ) internal view {\n    unchecked {\n      require(isOnCurve(pk), \"public key is not on curve\");\n      require(isOnCurve(gamma), \"gamma is not on curve\");\n      require(isOnCurve(cGammaWitness), \"cGammaWitness is not on curve\");\n      require(isOnCurve(sHashWitness), \"sHashWitness is not on curve\");\n      // Step 5. of IETF draft section 5.3 (pk corresponds to 5.3's Y, and here\n      // we use the address of u instead of u itself. Also, here we add the\n      // terms instead of taking the difference, and in the proof construction in\n      // vrf.GenerateProof, we correspondingly take the difference instead of\n      // taking the sum as they do in step 7 of section 5.1.)\n      require(verifyLinearCombinationWithGenerator(c, pk, s, uWitness), \"addr(c*pk+s*g)!=_uWitness\");\n      // Step 4. of IETF draft section 5.3 (pk corresponds to Y, seed to alpha_string)\n      uint256[2] memory hash = hashToCurve(pk, seed);\n      // Step 6. of IETF draft section 5.3, but see note for step 5 about +/- terms\n      uint256[2] memory v = linearCombination(c, gamma, cGammaWitness, s, hash, sHashWitness, zInv);\n      // Steps 7. and 8. of IETF draft section 5.3\n      uint256 derivedC = scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\n      require(c == derivedC, \"invalid proof\");\n    }\n  }\n\n  // Domain-separation tag for the hash used as the final VRF output.\n  // Corresponds to vrfRandomOutputHashPrefix in vrf.go\n  uint256 internal constant VRF_RANDOM_OUTPUT_HASH_PREFIX = 3;\n\n  struct Proof {\n    uint256[2] pk;\n    uint256[2] gamma;\n    uint256 c;\n    uint256 s;\n    uint256 seed;\n    address uWitness;\n    uint256[2] cGammaWitness;\n    uint256[2] sHashWitness;\n    uint256 zInv;\n  }\n\n  /* ***************************************************************************\n     * @notice Returns proof's output, if proof is valid. Otherwise reverts\n\n     * @param proof vrf proof components\n     * @param seed  seed used to generate the vrf output\n     *\n     * Throws if proof is invalid, otherwise:\n     * @return output i.e., the random output implied by the proof\n     * ***************************************************************************\n     */\n  function randomValueFromVRFProof(Proof memory proof, uint256 seed) internal view returns (uint256 output) {\n    verifyVRFProof(\n      proof.pk,\n      proof.gamma,\n      proof.c,\n      proof.s,\n      seed,\n      proof.uWitness,\n      proof.cGammaWitness,\n      proof.sHashWitness,\n      proof.zInv\n    );\n    output = uint256(keccak256(abi.encode(VRF_RANDOM_OUTPUT_HASH_PREFIX, proof.gamma)));\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/tests/VRFCoordinatorV2TestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../dev/VRFCoordinatorV2.sol\";\n\ncontract VRFCoordinatorV2TestHelper is VRFCoordinatorV2 {\n  uint96 s_paymentAmount;\n  uint256 s_gasStart;\n\n  constructor(\n    address link,\n    address blockhashStore,\n    address linkEthFeed\n  )\n    // solhint-disable-next-line no-empty-blocks\n    VRFCoordinatorV2(link, blockhashStore, linkEthFeed)\n  {\n    /* empty */\n  }\n\n  function calculatePaymentAmountTest(\n    uint256 gasAfterPaymentCalculation,\n    uint32 fulfillmentFlatFeeLinkPPM,\n    uint256 weiPerUnitGas\n  ) external {\n    s_paymentAmount = calculatePaymentAmount(\n      gasleft(),\n      gasAfterPaymentCalculation,\n      fulfillmentFlatFeeLinkPPM,\n      weiPerUnitGas\n    );\n  }\n\n  function getPaymentAmount() public view returns (uint96) {\n    return s_paymentAmount;\n  }\n\n  function getGasStart() public view returns (uint256) {\n    return s_gasStart;\n  }\n}\n"
    },
    "contracts/test/VRFCoordinatorV2TestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport {VRFCoordinatorV2TestHelper as Helper} from \"@chainlink/contracts/src/v0.8/tests/VRFCoordinatorV2TestHelper.sol\";\n\ncontract VRFCoordinatorV2TestHelper is Helper {\n    receive() external payable {}\n\n    constructor(\n        address link,\n        address blockhashStore,\n        address linkEthFeed\n    ) Helper(link, blockhashStore, linkEthFeed) {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}